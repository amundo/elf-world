<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>elf world</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20width%3D'48'%20height%3D'48'%20viewBox%3D'0%200%2016%2016'%3E%3Ctext%20x%3D'0'%20y%3D'14'%3E%F0%9F%A7%9D%E2%80%8D%E2%99%82%EF%B8%8F%3C%2Ftext%3E%3C%2Fsvg%3E" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: sans-serif;
    }

    .view {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    .world {
      position: absolute;
      display: grid;
      transition: transform 0.1s ease-out;
    }

    .tile {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
    }

    .player, .entity {
      position: absolute;
      display: grid;
      font-size: 2rem;
      place-content: center;
      width: 1px;
      height: 1px;
    }

    .ui {
      position: absolute;
      top: 0;
      left: 0;
      padding: 0.5rem;
      font-size: 1.2rem;
      background: rgba(255, 255, 255, 0.8);
    }

    .dialogue {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 1rem;
      font-size: 1.2rem;
      display: none;
    }
  </style>
</head>
<body>

<div class="view">
  <div id="world" class="world"></div>
  <div id="player" class="player">üßù‚Äç‚ôÇÔ∏è</div>
  <div class="ui" id="inventory">Inventory: üçé</div>
  <div class="dialogue" id="dialogueBox">Hello!</div>
</div>

<script>
  const COLS = 30
  const ROWS = 20
  const VIEW_WIDTH = 10
  const VIEW_HEIGHT = 8

  let tileWidth, tileHeight
  const worldEl = document.getElementById('world')
  const playerEl = document.getElementById('player')
  const dialogueBox = document.getElementById('dialogueBox')
  const inventoryEl = document.getElementById('inventory')

  const grid = Array.from({ length: ROWS }, () => Array(COLS).fill(null))

  class Entity {
    constructor({ x, y, emoji }) {
      this.x = x
      this.y = y
      this.emoji = emoji
      this.solid = false
      this.el = document.createElement('div')
      this.el.className = 'tile entity'
      this.el.textContent = emoji
      worldEl.appendChild(this.el)
      this.updatePosition()
    }
    updatePosition() {
      this.el.style.left = `${this.x * tileWidth}px`
      this.el.style.top = `${this.y * tileHeight}px`
      this.el.style.width = `${tileWidth}px`
      this.el.style.height = `${tileHeight}px`
    }
    onInteract(player) {}
  }

  class ObjectEntity extends Entity {
    constructor(data) {
      super(data)
      this.solid = true
    }
  }

  class Enemy extends Entity {
    onInteract(player) {
      showDialogue(`A wild ${this.emoji} appears!`, this)
    }
  }

  class NPC extends Entity {
    constructor(data) {
      super(data)
      this.dialogue = data.dialogue || "Hello!"
    }
    onInteract(player) {
      showDialogue(this.dialogue, this)
      if (!player.inventory.includes('üóùÔ∏è')) {
        player.inventory.push('üóùÔ∏è')
        updateInventory()
      }
    }
  }

  class Player {
    constructor({ x, y, emoji }) {
      this.x = x
      this.y = y
      this.emoji = emoji
      this.inventory = ['üçé']
      this.el = playerEl
    }
    update() {
      this.el.style.left = `${this.x * tileWidth}px`
      this.el.style.top = `${this.y * tileHeight}px`
      this.el.style.width = `${tileWidth}px`
      this.el.style.height = `${tileHeight}px`
    }
    move(dx, dy) {
      const tx = clamp(this.x + dx, 0, COLS - 1)
      const ty = clamp(this.y + dy, 0, ROWS - 1)
      const entity = grid[clamp(ty, 0, ROWS - 1)]?.[clamp(tx, 0, COLS - 1)]
      
      // Check if movement is blocked by solid entity
      if (entity?.solid) return
      
      // Move the player
      this.x = tx
      this.y = ty
      this.update()
      updateCamera()
      
      // Check for adjacent NPCs after moving
      this.checkAdjacentInteractions()
    }
    
    checkAdjacentInteractions() {
      const directions = [
        { dx: -1, dy: 0 },  // left
        { dx: 1, dy: 0 },   // right
        { dx: 0, dy: -1 },  // up
        { dx: 0, dy: 1 }    // down
      ]
      
      for (const dir of directions) {
        const checkX = this.x + dir.dx
        const checkY = this.y + dir.dy
        
        // Make sure we're within bounds
        if (checkX >= 0 && checkX < COLS && checkY >= 0 && checkY < ROWS) {
          const entity = grid[checkY][checkX]
          if (entity && (entity instanceof NPC || entity instanceof Enemy)) {
            entity.onInteract(this)
            break // Only interact with one entity at a time
          }
        }
      }
    }
  }

  const terrainOptions = [
    { type: 'object', emoji: 'üå≤', chance: 0.1 },
    { type: 'object', emoji: 'ü™®', chance: 0.05 },
    { type: 'enemy', emoji: 'üêç', chance: 0.03 },
    { type: 'enemy', emoji: 'ü¶á', chance: 0.02 },
    { type: 'npc', emoji: 'üë¥', chance: 0.02, dialogue: 'Welcome, traveler!' },
    { type: 'npc', emoji: 'üßô‚Äç‚ôÇÔ∏è', chance: 0.01, dialogue: 'Magic is real!' }
  ]

  const entityTypes = {
    object: ObjectEntity,
    enemy: Enemy,
    npc: NPC
  }

  const entities = []

  for (let y = 0; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      for (const option of terrainOptions) {
        if (Math.random() < option.chance) {
          const Cls = entityTypes[option.type]
          const data = { ...option, x, y }
          const entity = new Cls(data)
          grid[y][x] = entity
          entities.push(entity)
          break
        }
      }
    }
  }

  const player = new Player({ x: 2, y: 2, emoji: 'üßù‚Äç‚ôÇÔ∏è' })

  let cameraX = player.x
  let cameraY = player.y

  function clamp(val, min, max) {
    return Math.max(min, Math.min(max, val))
  }

  function updateInventory() {
    inventoryEl.textContent = `Inventory: ${player.inventory.join(' ')}`
  }

  function showDialogue(text, entity = null) {
    if (!entity) return

    let bubble = entity.el.querySelector('.speech-bubble')
    if (!bubble) {
      bubble = document.createElement('div')
      bubble.className = 'speech-bubble'
      bubble.style.position = 'absolute'; bubble.style.left = '50%'; bubble.style.top = '-0.2em'
      bubble.style.background = 'white'
      bubble.style.border = '1px solid black'
      bubble.style.padding = '4px 8px'
      bubble.style.borderRadius = '8px'
      bubble.style.fontSize = '1rem'
      bubble.style.zIndex = '20'
      bubble.style.whiteSpace = 'nowrap'
      bubble.style.transform = 'translate(-50%, -120%)'
      entity.el.appendChild(bubble)
    }
    bubble.textContent = text
    bubble.style.display = 'block'
    setTimeout(() => {
      if (bubble) bubble.style.display = 'none'
    }, 2000)
  }

  function updateCamera() {
    const marginX = Math.floor(VIEW_WIDTH / 2)
    const marginY = Math.floor(VIEW_HEIGHT / 2)
    if (player.x < cameraX - marginX + 1) cameraX = clamp(player.x + marginX - 1, marginX, COLS - marginX - 1)
    if (player.x > cameraX + marginX - 1) cameraX = clamp(player.x - marginX + 1, marginX, COLS - marginX - 1)
    if (player.y < cameraY - marginY + 1) cameraY = clamp(player.y + marginY - 1, marginY, ROWS - marginY - 1)
    if (player.y > cameraY + marginY - 1) cameraY = clamp(player.y - marginY + 1, marginY, ROWS - marginY - 1)

    const offsetX = clamp(cameraX - marginX, 0, COLS - VIEW_WIDTH) * tileWidth
    const offsetY = clamp(cameraY - marginY, 0, ROWS - VIEW_HEIGHT) * tileHeight
    worldEl.style.transform = `translate(${-offsetX}px, ${-offsetY}px)`
    player.el.style.transform = `translate(${-offsetX}px, ${-offsetY}px)`
    entities.forEach(e => e.el.style.transform = `translate(${-offsetX}px, ${-offsetY}px)`)
  }

  window.addEventListener('keydown', e => {
    if (e.key === 'ArrowLeft') player.move(-1, 0)
    else if (e.key === 'ArrowRight') player.move(1, 0)
    else if (e.key === 'ArrowUp') player.move(0, -1)
    else if (e.key === 'ArrowDown') player.move(0, 1)
  })

  function resizeTiles() {
    tileWidth = window.innerWidth / VIEW_WIDTH
    tileHeight = window.innerHeight / VIEW_HEIGHT
    worldEl.style.gridTemplateColumns = `repeat(${COLS}, ${tileWidth}px)`
    worldEl.style.gridTemplateRows = `repeat(${ROWS}, ${tileHeight}px)`
    worldEl.style.width = `${COLS * tileWidth}px`
    worldEl.style.height = `${ROWS * tileHeight}px`
    player.update()
    entities.forEach(e => e.updatePosition())
    updateCamera()
  }

  window.addEventListener('resize', resizeTiles)
  resizeTiles()
</script>
</body>
</html>