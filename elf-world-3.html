<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>elf world</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20width%3D'48'%20height%3D'48'%20viewBox%3D'0%200%2016%2016'%3E%3Ctext%20x%3D'0'%20y%3D'14'%3E%F0%9F%A7%9D%E2%80%8D%E2%99%82%EF%B8%8F%3C%2Ftext%3E%3C%2Fsvg%3E" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: sans-serif;
    }

    .view {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    .world {
      position: absolute;
      display: grid;
      transition: transform 0.3s ease-out;
    }

    .tile {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      position: relative;
      border: 1px solid rgba(0,0,0,0.05);
    }

    .entity {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }

    .player {
      z-index: 15;
    }

    .portal {
      z-index: 12;
      animation: portal-glow 2s ease-in-out infinite alternate;
    }

    @keyframes portal-glow {
      from { filter: brightness(1) drop-shadow(0 0 5px currentColor); }
      to { filter: brightness(1.3) drop-shadow(0 0 15px currentColor); }
    }

    .ui {
      position: absolute;
      top: 0;
      left: 0;
      padding: 0.5rem;
      font-size: 1.2rem;
      background: rgba(255, 255, 255, 0.8);
      z-index: 20;
    }

    .realm-info {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      padding: 0.5rem 1rem;
      font-size: 1.2rem;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      z-index: 20;
      border-radius: 0 0 8px 8px;
    }

    .audio-controls {
      position: absolute;
      top: 0;
      right: 0;
      padding: 0.5rem;
      background: rgba(255, 255, 255, 0.8);
      z-index: 20;
      font-size: 1.2rem;
      cursor: pointer;
      user-select: none;
    }

    .audio-controls:hover {
      background: rgba(255, 255, 255, 0.9);
    }

    .dialogue {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 1rem;
      font-size: 1.2rem;
      display: none;
      z-index: 20;
    }

    .realm-transition {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: black;
      z-index: 100;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease-in-out;
    }

    .realm-transition.active {
      opacity: 1;
    }
  </style>
</head>
<body>

<div class="view">
  <div id="world" class="world"></div>
  <div class="ui" id="inventory">Inventory: üçé</div>
  <div class="realm-info" id="realmInfo">Forest Realm</div>
  <div class="audio-controls" id="audioToggle">üîá</div>
  <div class="dialogue" id="dialogueBox">Hello!</div>
  <div class="realm-transition" id="transition"></div>
</div>

<script>
  const COLS = 30
  const ROWS = 20
  const VIEW_WIDTH = 10
  const VIEW_HEIGHT = 8

  let tileWidth, tileHeight
  const worldEl = document.getElementById('world')
  const dialogueBox = document.getElementById('dialogueBox')
  const inventoryEl = document.getElementById('inventory')
  const audioToggle = document.getElementById('audioToggle')
  const realmInfo = document.getElementById('realmInfo')
  const transition = document.getElementById('transition')

  // Current realm and audio
  let currentRealm = null
  let backgroundMusic = null
  let isPlaying = false

  // Grid of tile DOM elements
  const tileElements = Array.from({ length: ROWS }, () => Array(COLS).fill(null))
  // Grid of entity data
  const entityGrid = Array.from({ length: ROWS }, () => Array(COLS).fill(null))

  // Realm definitions
  const REALMS = {
    forest: {
      name: "Forest Realm",
      music: "audio/woodland-fantasy.mp3",
      terrain: {
        primary: { color: "#90EE90", weight: 0.7 },   // Light green
        secondary: { color: "#228B22", weight: 0.2 }, // Forest green  
        accent: { color: "#4169E1", weight: 0.1 }     // Blue (water)
      },
      entities: [
        { type: 'object', emoji: 'üå≤', chance: 0.12, solid: true },
        { type: 'object', emoji: 'ü™®', chance: 0.06, solid: true },
        { type: 'enemy', emoji: 'üêç', chance: 0.03, dialogue: 'A wild snake appears!' },
        { type: 'enemy', emoji: 'ü¶á', chance: 0.02, dialogue: 'A bat swoops down!' },
        { type: 'npc', emoji: 'üë¥', chance: 0.02, dialogue: 'Welcome to the forest, traveler!' },
        { type: 'npc', emoji: 'üßô‚Äç‚ôÇÔ∏è', chance: 0.01, dialogue: 'The forest magic is strong here!' },
        { type: 'portal', emoji: 'üåÄ', chance: 0.003, destination: 'wraith' },
        { type: 'portal', emoji: '‚ú®', chance: 0.003, destination: 'fairy' }
      ]
    },
    wraith: {
      name: "Wraith Realm", 
      music: "audio/the-wraiths-of-winter.mp3",
      terrain: {
        primary: { color: "#2F2F2F", weight: 0.6 },   // Dark gray
        secondary: { color: "#1C1C1C", weight: 0.3 }, // Very dark gray
        accent: { color: "#4B0082", weight: 0.1 }     // Dark purple
      },
      entities: [
        { type: 'object', emoji: 'ü™¶', chance: 0.08, solid: true },
        { type: 'object', emoji: 'üåô', chance: 0.03, solid: false },
        { type: 'enemy', emoji: 'üíÄ', chance: 0.04, dialogue: 'A skull rattles menacingly!' },
        { type: 'enemy', emoji: 'üßü', chance: 0.03, dialogue: 'A zombie groans and approaches!' },
        { type: 'enemy', emoji: 'üëª', chance: 0.02, dialogue: 'A wraith materializes before you!' },
        { type: 'npc', emoji: 'üßô‚Äç‚ôÄÔ∏è', chance: 0.01, dialogue: 'The dead whisper secrets here...' },
        { type: 'npc', emoji: 'üîÆ', chance: 0.005, dialogue: 'The crystal shows visions of other realms...' },
        { type: 'npc', emoji: 'üîÆ', chance: 0.005, dialogue: 'The crystal shows visions of other realms...' },
        { type: 'portal', emoji: 'üåÄ', chance: 0.003, destination: 'forest' },
        { type: 'portal', emoji: '‚ú®', chance: 0.003, destination: 'fairy' }
      ]
    },
    fairy: {
      name: "Fairy Realm",
      music: "audio/epic-orchestral-fantasy.mp3", 
      terrain: {
        primary: { color: "#FFB6C1", weight: 0.4 },   // Light pink
        secondary: { color: "#E6E6FA", weight: 0.3 }, // Lavender
        accent: { color: "#98FB98", weight: 0.3 }     // Pale green
      },
      entities: [
        { type: 'object', emoji: 'üå∏', chance: 0.15, solid: false },
        { type: 'object', emoji: 'üå∫', chance: 0.08, solid: false },
        { type: 'object', emoji: 'üçÑ', chance: 0.1, solid: true },
        { type: 'object', emoji: 'ü¶ã', chance: 0.06, solid: false },
        { type: 'enemy', emoji: 'üêù', chance: 0.02, dialogue: 'A magical bee buzzes around you!' },
        { type: 'enemy', emoji: 'ü¶Ñ', chance: 0.01, dialogue: 'A unicorn prances nearby, but seems wary!' },
        { type: 'npc', emoji: 'üßö‚Äç‚ôÄÔ∏è', chance: 0.04, dialogue: 'Welcome to our enchanted realm!' },
        { type: 'npc', emoji: 'üßö‚Äç‚ôÇÔ∏è', chance: 0.03, dialogue: 'The fairy magic flows strong here!' },
        { type: 'npc', emoji: 'üëë', chance: 0.005, dialogue: 'I am the Fairy Queen. You are welcome in my domain.' },
        { type: 'portal', emoji: 'üåÄ', chance: 0.003, destination: 'forest' },
        { type: 'portal', emoji: 'üå´Ô∏è', chance: 0.003, destination: 'wraith' }
      ]
    }
  }

  class Entity {
    constructor({ x, y, emoji, type = 'entity', solid = false, dialogue = null, destination = null }) {
      this.x = x
      this.y = y
      this.emoji = emoji
      this.type = type
      this.solid = solid
      this.dialogue = dialogue
      this.destination = destination
      this.el = document.createElement('div')
      this.el.className = `entity ${type}`
      this.el.textContent = emoji
      
      // Add to the appropriate tile
      const tile = tileElements[y][x]
      if (tile) {
        tile.appendChild(this.el)
      }
      
      entityGrid[y][x] = this
    }
    
    moveTo(newX, newY) {
      // Remove from old position
      if (this.el.parentElement) {
        this.el.parentElement.removeChild(this.el)
      }
      entityGrid[this.y][this.x] = null
      
      // Add to new position
      this.x = newX
      this.y = newY
      const tile = tileElements[newY][newX]
      if (tile) {
        tile.appendChild(this.el)
      }
      entityGrid[newY][newX] = this
    }
    
    onInteract(player) {
      if (this.type === 'portal') {
        switchRealm(this.destination)
      } else if (this.dialogue) {
        showDialogue(this.dialogue, this)
      }
    }
  }

  class Player extends Entity {
    constructor({ x, y, emoji }) {
      super({ x, y, emoji, type: 'player' })
      this.inventory = ['üçé']
    }
    
    move(dx, dy) {
      const tx = clamp(this.x + dx, 0, COLS - 1)
      const ty = clamp(this.y + dy, 0, ROWS - 1)
      const entity = entityGrid[ty][tx]
      
      // Check if movement is blocked by solid entity
      if (entity?.solid) return
      
      // Handle portal interaction
      if (entity?.type === 'portal') {
        entity.onInteract(this)
        return
      }
      
      // Move the player
      this.moveTo(tx, ty)
      updateCamera()
      
      // Check for adjacent NPCs after moving
      this.checkAdjacentInteractions()
    }
    
    checkAdjacentInteractions() {
      const directions = [
        { dx: -1, dy: 0 },  // left
        { dx: 1, dy: 0 },   // right
        { dx: 0, dy: -1 },  // up
        { dx: 0, dy: 1 }    // down
      ]
      
      for (const dir of directions) {
        const checkX = this.x + dir.dx
        const checkY = this.y + dir.dy
        
        // Make sure we're within bounds
        if (checkX >= 0 && checkX < COLS && checkY >= 0 && checkY < ROWS) {
          const entity = entityGrid[checkY][checkX]
          if (entity && (entity.type === 'npc' || entity.type === 'enemy')) {
            entity.onInteract(this)
            break // Only interact with one entity at a time
          }
        }
      }
    }
  }

  function createTileGrid() {
    // Clear existing tiles
    worldEl.innerHTML = ''
    
    // Create all tile DOM elements
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        const tile = document.createElement('div')
        tile.className = 'tile'
        tile.dataset.x = x
        tile.dataset.y = y
        
        worldEl.appendChild(tile)
        tileElements[y][x] = tile
      }
    }
  }

  function applyRealmTerrain(realm) {
    const terrain = realm.terrain
    
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        const tile = tileElements[y][x]
        const rand = Math.random()
        
        if (rand < terrain.accent.weight) {
          tile.style.backgroundColor = terrain.accent.color
        } else if (rand < terrain.accent.weight + terrain.secondary.weight) {
          tile.style.backgroundColor = terrain.secondary.color
        } else {
          tile.style.backgroundColor = terrain.primary.color
        }
      }
    }
  }

  function clearEntities() {
    // Clear entity grid
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        entityGrid[y][x] = null
        // Remove entity elements from tiles
        const tile = tileElements[y][x]
        if (tile) {
          const entities = tile.querySelectorAll('.entity:not(.player)')
          entities.forEach(entity => entity.remove())
        }
      }
    }
  }

  function generateEntities(realm) {
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        // Skip player position
        if (player && x === player.x && y === player.y) continue
        
        for (const entityDef of realm.entities) {
          if (Math.random() < entityDef.chance) {
            new Entity({
              x, y,
              emoji: entityDef.emoji,
              type: entityDef.type,
              solid: entityDef.solid,
              dialogue: entityDef.dialogue,
              destination: entityDef.destination
            })
            break
          }
        }
      }
    }
  }

  function switchRealm(realmKey) {
    const newRealm = REALMS[realmKey]
    if (!newRealm || newRealm === currentRealm) return
    
    // Show transition
    transition.classList.add('active')
    
    setTimeout(() => {
      // Stop current music
      if (backgroundMusic) {
        backgroundMusic.pause()
        backgroundMusic.currentTime = 0
      }
      
      // Update realm
      currentRealm = newRealm
      realmInfo.textContent = newRealm.name
      
      // Clear and regenerate world
      clearEntities()
      applyRealmTerrain(newRealm)
      generateEntities(newRealm)
      
      console.log(newRealm.music)
      // Update music
      backgroundMusic = new Audio(newRealm.music)
      backgroundMusic.loop = true
      backgroundMusic.volume = 0.3
      
      if (isPlaying) {
        backgroundMusic.play().catch(e => console.log('Audio play failed:', e))
      }
      
      // Move player to a safe spot (find empty tile)
      let newX = 2, newY = 2
      for (let attempts = 0; attempts < 50; attempts++) {
        const testX = Math.floor(Math.random() * COLS)
        const testY = Math.floor(Math.random() * ROWS)
        if (!entityGrid[testY][testX]) {
          newX = testX
          newY = testY
          break
        }
      }
      player.moveTo(newX, newY)
      updateCamera()
      
      // Hide transition
      setTimeout(() => {
        transition.classList.remove('active')
      }, 250)
    }, 250)
  }

  let cameraX = 2
  let cameraY = 2

  function clamp(val, min, max) {
    return Math.max(min, Math.min(max, val))
  }

  function updateInventory() {
    inventoryEl.textContent = `Inventory: ${player.inventory.join(' ')}`
  }

  function showDialogue(text, entity = null) {
    if (!entity) return

    let bubble = entity.el.querySelector('.speech-bubble')
    if (!bubble) {
      bubble = document.createElement('div')
      bubble.className = 'speech-bubble'
      bubble.style.position = 'absolute'
      bubble.style.left = '50%'
      bubble.style.top = '-0.2em'
      bubble.style.background = 'white'
      bubble.style.border = '1px solid black'
      bubble.style.padding = '4px 8px'
      bubble.style.borderRadius = '8px'
      bubble.style.fontSize = '1rem'
      bubble.style.zIndex = '30'
      bubble.style.whiteSpace = 'nowrap'
      bubble.style.transform = 'translate(-50%, -120%)'
      entity.el.appendChild(bubble)
    }
    bubble.textContent = text
    bubble.style.display = 'block'
    setTimeout(() => {
      if (bubble) bubble.style.display = 'none'
    }, 2000)
  }

  function updateCamera() {
    const marginX = Math.floor(VIEW_WIDTH / 2)
    const marginY = Math.floor(VIEW_HEIGHT / 2)
    
    if (player.x < cameraX - marginX + 1) cameraX = clamp(player.x + marginX - 1, marginX, COLS - marginX - 1)
    if (player.x > cameraX + marginX - 1) cameraX = clamp(player.x - marginX + 1, marginX, COLS - marginX - 1)
    if (player.y < cameraY - marginY + 1) cameraY = clamp(player.y + marginY - 1, marginY, ROWS - marginY - 1)
    if (player.y > cameraY + marginY - 1) cameraY = clamp(player.y - marginY + 1, marginY, ROWS - marginY - 1)

    const offsetX = clamp(cameraX - marginX, 0, COLS - VIEW_WIDTH) * tileWidth
    const offsetY = clamp(cameraY - marginY, 0, ROWS - VIEW_HEIGHT) * tileHeight
    worldEl.style.transform = `translate(${-offsetX}px, ${-offsetY}px)`
  }

  function toggleAudio() {
    if (isPlaying) {
      if (backgroundMusic) backgroundMusic.pause()
      audioToggle.textContent = 'üîá'
      isPlaying = false
    } else {
      if (backgroundMusic) {
        backgroundMusic.play().catch(e => console.log('Audio play failed:', e))
      }
      audioToggle.textContent = 'üîä'
      isPlaying = true
    }
  }

  window.addEventListener('keydown', e => {
    if (e.key === 'ArrowLeft') player.move(-1, 0)
    else if (e.key === 'ArrowRight') player.move(1, 0)
    else if (e.key === 'ArrowUp') player.move(0, -1)
    else if (e.key === 'ArrowDown') player.move(0, 1)
  })

  function resizeTiles() {
    tileWidth = window.innerWidth / VIEW_WIDTH
    tileHeight = window.innerHeight / VIEW_HEIGHT
    worldEl.style.gridTemplateColumns = `repeat(${COLS}, ${tileWidth}px)`
    worldEl.style.gridTemplateRows = `repeat(${ROWS}, ${tileHeight}px)`
    worldEl.style.width = `${COLS * tileWidth}px`
    worldEl.style.height = `${ROWS * tileHeight}px`
    updateCamera()
  }

  audioToggle.addEventListener('click', toggleAudio)

  // Initialize the game
  let player = null
  
  function initializeGame() {
    createTileGrid()
    player = new Player({ x: 2, y: 2, emoji: 'üßù‚Äç‚ôÇÔ∏è' })
    switchRealm('forest') // Start in forest realm
  }

  window.addEventListener('resize', resizeTiles)
  
  initializeGame()
  resizeTiles()
</script>
</body>
</html>