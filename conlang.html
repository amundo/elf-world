<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>elf world</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20width%3D'48'%20height%3D'48'%20viewBox%3D'0%200%2016%2016'%3E%3Ctext%20x%3D'0'%20y%3D'14'%3E%F0%9F%A7%9D%E2%80%8D%E2%99%82%EF%B8%8F%3C%2Ftext%3E%3C%2Fsvg%3E" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: sans-serif;
    }

    .view {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      display: flex;
    }

    .game-pane {
      flex: 1;
      position: relative;
      overflow: hidden;
    }

    .console-pane {
      width: 400px;
      background: rgba(0, 0, 0, 0.95);
      color: #00ff00;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      border-left: 2px solid #333;
    }

    .world {
      position: absolute;
      display: grid;
      transition: transform 0.3s ease-out;
      width: 100%;
      height: 100%;
    }

    .tile {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      position: relative;
      border: 1px solid rgba(0,0,0,0.05);
    }

    .entity {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }

    .player {
      z-index: 15;
    }

    .portal {
      z-index: 12;
      animation: portal-glow 2s ease-in-out infinite alternate;
    }

    @keyframes portal-glow {
      from { filter: brightness(1) drop-shadow(0 0 5px currentColor); }
      to { filter: brightness(1.3) drop-shadow(0 0 15px currentColor); }
    }

    .ui {
      position: absolute;
      top: 0;
      left: 0;
      padding: 0.5rem;
      font-size: 1.2rem;
      background: rgba(255, 255, 255, 0.8);
      z-index: 20;
    }

    .realm-info {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      padding: 0.5rem 1rem;
      font-size: 1.2rem;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      z-index: 20;
      border-radius: 0 0 8px 8px;
    }

    .audio-controls {
      position: absolute;
      top: 0;
      right: 0;
      padding: 0.5rem;
      background: rgba(255, 255, 255, 0.8);
      z-index: 20;
      font-size: 1.2rem;
      cursor: pointer;
      user-select: none;
    }

    .audio-controls:hover {
      background: rgba(255, 255, 255, 0.9);
    }

    .dialogue {
      position: absolute;
      bottom: 10px;
      left: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 1rem;
      font-size: 1.2rem;
      display: none;
      z-index: 20;
      border-radius: 8px;
    }

    .console-header {
      background: rgba(0, 0, 0, 0.8);
      color: #00ff00;
      padding: 0.5rem;
      border-bottom: 1px solid #333;
      font-weight: bold;
      text-align: center;
    }

    .command-output {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
      font-size: 0.9rem;
      min-height: 0;
    }

    .command-output div {
      margin: 2px 0;
      line-height: 1.4;
    }

    .command-input-area {
      padding: 0.5rem;
      border-top: 1px solid #333;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .command-prompt {
      color: #00ff00;
      font-weight: bold;
    }

    .command-input {
      flex: 1;
      background: transparent;
      border: none;
      color: #00ff00;
      font-family: 'Courier New', monospace;
      font-size: 1rem;
      outline: none;
    }

    .error { color: #ff6666; }
    .success { color: #66ff66; }
    .info { color: #6666ff; }

    .realm-transition {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: black;
      z-index: 100;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease-in-out;
    }

    .realm-transition.active {
      opacity: 1;
    }
  </style>
</head>
<body>

<div class="view">
  <div class="game-pane">
    <div id="world" class="world"></div>
    <div class="ui" id="inventory">Inventory: üçé</div>
    <div class="realm-info" id="realmInfo">Forest Realm</div>
    <div class="audio-controls" id="audioToggle">üîá</div>
    <div class="dialogue" id="dialogueBox">Hello!</div>
    <div class="realm-transition" id="transition"></div>
  </div>
  
  <div class="console-pane">
    <div class="console-header" id="consoleHeader">WORD LEARN</div>
    <div class="command-output" id="commandOutput"></div>
    <div class="command-input-area">
      <span class="command-prompt">></span>
      <input type="text" class="command-input" id="commandInput" placeholder="">
    </div>
  </div>
</div>

<script type="module">
  import { ConlangEngine } from './ConlangEngine.js'
  const COLS = 30
  const ROWS = 20
  const VIEW_WIDTH = 10
  const VIEW_HEIGHT = 8

  let tileWidth, tileHeight
  const worldEl = document.getElementById('world')
  const dialogueBox = document.getElementById('dialogueBox')
  const inventoryEl = document.getElementById('inventory')
  const audioToggle = document.getElementById('audioToggle')
  const realmInfo = document.getElementById('realmInfo')
  const transition = document.getElementById('transition')
  const commandInput = document.getElementById('commandInput')
  const commandOutput = document.getElementById('commandOutput')

  // Conlang system
  class Conlang {
    constructor() {
      // Simple phone inventory
      this.consonants = ['p', 't', 'k', 's', 'n', 'm', 'l', 'r', 'w', 'j']
      this.vowels = ['a', 'e', 'i', 'o', 'u']
      
      // Syllable structures: CV, CVC, V, VC
      this.syllableStructures = ['CV', 'CVC', 'V', 'VC']
      
      // Phonetic patterns for semantic categories
      this.categoryPatterns = {
        movement: { suffix: 'en', prefix: '', vowel: 'a' },      // *-en endings
        spatial: { suffix: 'i', prefix: 'p', vowel: 'i' },      // pi- beginnings
        interrogative: { suffix: 'an', prefix: '', vowel: 'o' }, // *-an endings
        perception: { suffix: 'ir', prefix: 'm', vowel: 'i' },  // m*ir patterns
        basic: { suffix: 'ul', prefix: '', vowel: 'u' },        // *-ul endings
        social: { suffix: 'es', prefix: 'k', vowel: 'e' },      // k*es patterns
        state: { suffix: 'ol', prefix: 's', vowel: 'o' }        // s*ol patterns
      }
      
      // Seed lexicon with structured data
      this.seedLexicon = [
        { form: "", gloss: "WHAT", category: "interrogative", pos: "PRONOUN" },
        { form: "", gloss: "THIS", category: "spatial", pos: "DEMONSTRATIVE" },
        { form: "", gloss: "GO", category: "movement", pos: "VERB" },
        { form: "", gloss: "HERE", category: "spatial", pos: "ADVERB" },
        { form: "", gloss: "WHERE", category: "spatial", pos: "INTERROGATIVE" },
        { form: "", gloss: "SEE", category: "perception", pos: "VERB" },
        { form: "", gloss: "HEAR", category: "perception", pos: "VERB" },
        { form: "", gloss: "TAKE", category: "basic", pos: "VERB" },
        { form: "", gloss: "USE", category: "basic", pos: "VERB" },
        { form: "", gloss: "OPEN", category: "basic", pos: "VERB" },
        { form: "", gloss: "SAY", category: "social", pos: "VERB" },
        { form: "", gloss: "HELLO", category: "social", pos: "INTERJECTION" },
        { form: "", gloss: "WHO", category: "interrogative", pos: "PRONOUN" },
        { form: "", gloss: "HOW", category: "interrogative", pos: "ADVERB" },
        { form: "", gloss: "HAVE", category: "state", pos: "VERB" },
        { form: "", gloss: "KNOW", category: "state", pos: "VERB" }
      ]
      
      // Word cache to ensure consistency
      this.lexicon = new Map()
      
      // Initialize lexicon
      this.initializeLexicon()
    }
    
    initializeLexicon() {
      // Generate forms for seed lexicon using phonetic patterns
      for (const entry of this.seedLexicon) {
        entry.form = this.generateCategoricalWord(entry.category, entry.gloss)
        this.lexicon.set(entry.gloss.toLowerCase(), {
          form: entry.form,
          gloss: entry.gloss,
          category: entry.category,
          pos: entry.pos
        })
      }
      
      // Add entity words with their own patterns
      const entityWords = {
        'tree': 'forest', 'rock': 'forest', 'snake': 'forest', 'bat': 'forest',
        'wizard': 'forest', 'elder': 'forest', 'portal': 'magic',
        'skull': 'wraith', 'zombie': 'wraith', 'ghost': 'wraith', 'grave': 'wraith',
        'flower': 'fairy', 'butterfly': 'fairy', 'bee': 'fairy', 'unicorn': 'fairy',
        'fairy': 'fairy', 'queen': 'fairy', 'player': 'basic', 'elf': 'fairy'
      }
      
      for (const [concept, category] of Object.entries(entityWords)) {
        const form = this.generateCategoricalWord(category, concept)
        this.lexicon.set(concept, {
          form: form,
          gloss: concept.toUpperCase(),
          category: category,
          pos: 'NOUN'
        })
      }
    }
    
    generateCategoricalWord(category, concept) {
      const pattern = this.categoryPatterns[category] || this.categoryPatterns.basic
      
      // Generate base syllable
      let base = ''
      const useCV = Math.random() < 0.7
      
      if (useCV) {
        // CV structure
        base = this.getRandomConsonant() + pattern.vowel
      } else {
        // CVC structure  
        base = this.getRandomConsonant() + pattern.vowel + this.getRandomConsonant()
      }
      
      // Apply pattern
      let word = ''
      if (pattern.prefix) {
        word = pattern.prefix + base
      } else {
        word = base
      }
      
      if (pattern.suffix) {
        word = word + pattern.suffix
      }
      
      return word
    }
    
    getRandomConsonant() {
      return this.consonants[Math.floor(Math.random() * this.consonants.length)]
    }
    
    getRandomVowel() {
      return this.vowels[Math.floor(Math.random() * this.vowels.length)]
    }
    
    generateSyllable(structure) {
      let syllable = ''
      
      for (const segment of structure) {
        if (segment === 'C') {
          syllable += this.getRandomConsonant()
        } else if (segment === 'V') {
          syllable += this.getRandomVowel()
        }
      }
      
      return syllable
    }
    
    generateWord(concept, syllableCount = null, category = 'basic') {
      if (this.lexicon.has(concept.toLowerCase())) {
        return this.lexicon.get(concept.toLowerCase()).form
      }
      
      // Generate word using categorical patterns
      const form = this.generateCategoricalWord(category, concept)
      
      this.lexicon.set(concept.toLowerCase(), {
        form: form,
        gloss: concept.toUpperCase(),
        category: category,
        pos: 'NOUN'
      })
      
      return form
    }
    
    getWord(concept) {
      const entry = this.lexicon.get(concept.toLowerCase())
      return entry ? entry.form : this.generateWord(concept)
    }
    
    getEntry(concept) {
      return this.lexicon.get(concept.toLowerCase())
    }
    
    getAllKnownWords() {
      return Array.from(this.lexicon.entries())
    }
  }

  // Current realm and audio
  let currentRealm = null
  let backgroundMusic = null
  let isPlaying = false


  const conlang = new ConlangEngine({ seed: Math.floor(Math.random() * 10000) })
  
  // Player's learned vocabulary - start with basic seed words
  const knownWords = new Set(['what', 'this'])
  
  // Game state
  let selectedEntity = null
  let focusedEntity = null

  // Gloss parser and UI translation
  function translateGloss(glossText) {
    // Simple gloss parser - converts [GLOSS TEXT] to conlang
    const glossPattern = /\[([^\]]+)\]/g
    return glossText.replace(glossPattern, (match, gloss) => {
      const words = gloss.split(' ')
      return words.map(word => {
        const entry = conlang.getEntry(word.toLowerCase())
        return entry ? entry.form : word.toLowerCase()
      }).join(' ')
    })
  }
  
  function getUIText(key) {
    // UI text stored as gloss, converted to conlang
    const uiGlosses = {
      consoleHeader: '[WORD LEARN]',
      inventoryLabel: '[HAVE]:',
      welcomeMessage: '[HELLO] [WORD] [WORLD]!',
      helpHint: '[SAY] "[WHAT]" [NEAR] [THING]',
      unknownCommand: '[NOT] [KNOW] [WORD]',
      notNear: '[NOT] [NEAR]',
      learned: '[NOW] [KNOW]:',
      youSay: '[SAY]:',
      youSee: '[SEE]:',
      focus: '[THIS]:'
    }
    
    const gloss = uiGlosses[key] || key
    return translateGloss(gloss)
  }

  // Grid of tile DOM elements
  const tileElements = Array.from({ length: ROWS }, () => Array(COLS).fill(null))
  // Grid of entity data
  const entityGrid = Array.from({ length: ROWS }, () => Array(COLS).fill(null))

  // Realm definitions
  const REALMS = {
    forest: {
      name: "Forest Realm",
      music: "audio/woodland-fantasy.mp3",
      terrain: {
        primary: { color: "#90EE90", weight: 0.7 },   // Light green
        secondary: { color: "#228B22", weight: 0.2 }, // Forest green  
        accent: { color: "#4169E1", weight: 0.1 }     // Blue (water)
      },
      entities: [
        { type: 'object', emoji: 'üå≤', chance: 0.12, solid: true },
        { type: 'object', emoji: 'ü™®', chance: 0.06, solid: true },
        { type: 'enemy', emoji: 'üêç', chance: 0.03, dialogue: 'A wild snake appears!' },
        { type: 'enemy', emoji: 'ü¶á', chance: 0.02, dialogue: 'A bat swoops down!' },
        { type: 'npc', emoji: 'üë¥', chance: 0.02, dialogue: 'Welcome to the forest, traveler!' },
        { type: 'npc', emoji: 'üßô‚Äç‚ôÇÔ∏è', chance: 0.01, dialogue: 'The forest magic is strong here!' },
        { type: 'portal', emoji: 'üåÄ', chance: 0.003, destination: 'wraith' },
        { type: 'portal', emoji: '‚ú®', chance: 0.003, destination: 'fairy' }
      ]
    },
    wraith: {
      name: "Wraith Realm", 
      music: "audio/the-wraiths-of-winter.mp3",
      terrain: {
        primary: { color: "#2F2F2F", weight: 0.6 },   // Dark gray
        secondary: { color: "#1C1C1C", weight: 0.3 }, // Very dark gray
        accent: { color: "#4B0082", weight: 0.1 }     // Dark purple
      },
      entities: [
        { type: 'object', emoji: 'ü™¶', chance: 0.08, solid: true },
        { type: 'object', emoji: 'üåô', chance: 0.03, solid: false },
        { type: 'enemy', emoji: 'üíÄ', chance: 0.04, dialogue: 'A skull rattles menacingly!' },
        { type: 'enemy', emoji: 'üßü', chance: 0.03, dialogue: 'A zombie groans and approaches!' },
        { type: 'enemy', emoji: 'üëª', chance: 0.02, dialogue: 'A wraith materializes before you!' },
        { type: 'npc', emoji: 'üßô‚Äç‚ôÄÔ∏è', chance: 0.01, dialogue: 'The dead whisper secrets here...' },
        { type: 'npc', emoji: 'üîÆ', chance: 0.005, dialogue: 'The crystal shows visions of other realms...' },
        { type: 'npc', emoji: 'üîÆ', chance: 0.005, dialogue: 'The crystal shows visions of other realms...' },
        { type: 'portal', emoji: 'üåÄ', chance: 0.003, destination: 'forest' },
        { type: 'portal', emoji: '‚ú®', chance: 0.003, destination: 'fairy' }
      ]
    },
    fairy: {
      name: "Fairy Realm",
      music: "audio/epic-orchestral-fantasy.mp3", 
      terrain: {
        primary: { color: "#FFB6C1", weight: 0.4 },   // Light pink
        secondary: { color: "#E6E6FA", weight: 0.3 }, // Lavender
        accent: { color: "#98FB98", weight: 0.3 }     // Pale green
      },
      entities: [
        { type: 'object', emoji: 'üå∏', chance: 0.15, solid: false },
        { type: 'object', emoji: 'üå∫', chance: 0.08, solid: false },
        { type: 'object', emoji: 'üçÑ', chance: 0.1, solid: true },
        { type: 'object', emoji: 'ü¶ã', chance: 0.06, solid: false },
        { type: 'enemy', emoji: 'üêù', chance: 0.02, dialogue: 'A magical bee buzzes around you!' },
        { type: 'enemy', emoji: 'ü¶Ñ', chance: 0.01, dialogue: 'A unicorn prances nearby, but seems wary!' },
        { type: 'npc', emoji: 'üßö‚Äç‚ôÄÔ∏è', chance: 0.04, dialogue: 'Welcome to our enchanted realm!' },
        { type: 'npc', emoji: 'üßö‚Äç‚ôÇÔ∏è', chance: 0.03, dialogue: 'The fairy magic flows strong here!' },
        { type: 'npc', emoji: 'üëë', chance: 0.005, dialogue: 'I am the Fairy Queen. You are welcome in my domain.' },
        { type: 'portal', emoji: 'üåÄ', chance: 0.003, destination: 'forest' },
        { type: 'portal', emoji: 'üå´Ô∏è', chance: 0.003, destination: 'wraith' }
      ]
    }
  }

  class Entity {
    constructor({ x, y, emoji, type = 'entity', solid = false, dialogue = null, destination = null }) {
      this.x = x
      this.y = y
      this.emoji = emoji
      this.type = type
      this.solid = solid
      this.dialogue = dialogue
      this.destination = destination
      
      // Generate conlang name based on emoji/type
      this.concept = this.getConceptFromEmoji(emoji)
      this.conlangName = conlang.getWord(this.concept)
      
      this.el = document.createElement('div')
      this.el.className = `entity ${type}`
      this.el.textContent = emoji
      this.el.title = `${this.concept} (${this.conlangName})`
      
      // Add click handler for inspection
      this.el.addEventListener('click', () => this.inspect())
      
      // Add to the appropriate tile
      const tile = tileElements[y][x]
      if (tile) {
        tile.appendChild(this.el)
      }
      
      entityGrid[y][x] = this
    }
    
    getConceptFromEmoji(emoji) {
      const emojiMap = {
        'üå≤': 'tree', 'ü™®': 'rock', 'üêç': 'snake', 'ü¶á': 'bat',
        'üë¥': 'elder', 'üßô‚Äç‚ôÇÔ∏è': 'wizard', 'üåÄ': 'portal', '‚ú®': 'portal',
        'üå´Ô∏è': 'portal', 'ü™¶': 'grave', 'üåô': 'moon', 'üíÄ': 'skull',
        'üßü': 'zombie', 'üëª': 'ghost', 'üßô‚Äç‚ôÄÔ∏è': 'witch', 'üîÆ': 'crystal',
        'üå∏': 'flower', 'üå∫': 'flower', 'üçÑ': 'mushroom', 'ü¶ã': 'butterfly',
        'üêù': 'bee', 'ü¶Ñ': 'unicorn', 'üßö‚Äç‚ôÄÔ∏è': 'fairy', 'üßö‚Äç‚ôÇÔ∏è': 'fairy',
        'üëë': 'queen'
      }
      return emojiMap[emoji] || 'entity'
    }
    
    inspect() {
      const isKnown = knownWords.has(this.concept)
      const name = isKnown ? this.conlangName : '???'
      
      addCommandOutput(`${getUIText('youSee')} ${this.emoji}`, 'info')
      if (isKnown) {
        addCommandOutput(`${this.conlangName}`, 'success')
      } else {
        addCommandOutput(`${getUIText('unknownCommand')}`, 'info')
      }
      
      selectedEntity = this
    }
    
    moveTo(newX, newY) {
      // Remove from old position
      if (this.el.parentElement) {
        this.el.parentElement.removeChild(this.el)
      }
      entityGrid[this.y][this.x] = null
      
      // Add to new position
      this.x = newX
      this.y = newY
      const tile = tileElements[newY][newX]
      if (tile) {
        tile.appendChild(this.el)
      }
      entityGrid[newY][newX] = this
    }
    
    onInteract(player) {
      if (this.type === 'portal') {
        switchRealm(this.destination)
      } else if (this.dialogue) {
        // Check if player knows the word for greeting
        const greeting = knownWords.has('hello') ? conlang.getWord('hello') : 'hello'
        showDialogue(`${greeting}! ${this.dialogue}`, this)
      }
    }
  }

  class Player extends Entity {
    constructor({ x, y, emoji }) {
      super({ x, y, emoji, type: 'player' })
      this.inventory = ['üçé']
      this.concept = 'player'
      this.conlangName = conlang.getWord('player')
    }
    
    move(dx, dy) {
      const tx = clamp(this.x + dx, 0, COLS - 1)
      const ty = clamp(this.y + dy, 0, ROWS - 1)
      const entity = entityGrid[ty][tx]
      
      // Check if movement is blocked by solid entity
      if (entity?.solid) return
      
      // Handle portal interaction
      if (entity?.type === 'portal') {
        entity.onInteract(this)
        return
      }
      
      // Move the player
      this.moveTo(tx, ty)
      updateCamera()
      
      // Check for adjacent NPCs after moving
      this.checkAdjacentInteractions()
    }
    
    checkAdjacentInteractions() {
      const directions = [
        { dx: -1, dy: 0 },  // left
        { dx: 1, dy: 0 },   // right
        { dx: 0, dy: -1 },  // up
        { dx: 0, dy: 1 }    // down
      ]
      
      // Find closest entity for focus
      let closestEntity = null
      let closestDistance = Infinity
      
      for (const dir of directions) {
        const checkX = this.x + dir.dx
        const checkY = this.y + dir.dy
        
        if (checkX >= 0 && checkX < COLS && checkY >= 0 && checkY < ROWS) {
          const entity = entityGrid[checkY][checkX]
          if (entity && entity !== player) {
            const distance = Math.abs(dir.dx) + Math.abs(dir.dy)
            if (distance < closestDistance) {
              closestDistance = distance
              closestEntity = entity
            }
          }
        }
      }
      
      // Update focus
      if (focusedEntity !== closestEntity) {
        focusedEntity = closestEntity
        if (focusedEntity) {
          addCommandOutput(`${getUIText('focus')} ${focusedEntity.emoji}`, 'info')
        }
      }
      
      // Handle NPC interactions
      for (const dir of directions) {
        const checkX = this.x + dir.dx
        const checkY = this.y + dir.dy
        
        if (checkX >= 0 && checkX < COLS && checkY >= 0 && checkY < ROWS) {
          const entity = entityGrid[checkY][checkX]
          if (entity && (entity.type === 'npc' || entity.type === 'enemy')) {
            entity.onInteract(this)
            break
          }
        }
      }
    }
  }

  function createTileGrid() {
    // Clear existing tiles
    worldEl.innerHTML = ''
    
    // Create all tile DOM elements
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        const tile = document.createElement('div')
        tile.className = 'tile'
        tile.dataset.x = x
        tile.dataset.y = y
        
        worldEl.appendChild(tile)
        tileElements[y][x] = tile
      }
    }
  }

  function applyRealmTerrain(realm) {
    const terrain = realm.terrain
    
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        const tile = tileElements[y][x]
        const rand = Math.random()
        
        if (rand < terrain.accent.weight) {
          tile.style.backgroundColor = terrain.accent.color
        } else if (rand < terrain.accent.weight + terrain.secondary.weight) {
          tile.style.backgroundColor = terrain.secondary.color
        } else {
          tile.style.backgroundColor = terrain.primary.color
        }
      }
    }
  }

  function clearEntities() {
    // Clear entity grid
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        entityGrid[y][x] = null
        // Remove entity elements from tiles
        const tile = tileElements[y][x]
        if (tile) {
          const entities = tile.querySelectorAll('.entity:not(.player)')
          entities.forEach(entity => entity.remove())
        }
      }
    }
  }

  function generateEntities(realm) {
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        // Skip player position
        if (player && x === player.x && y === player.y) continue
        
        for (const entityDef of realm.entities) {
          if (Math.random() < entityDef.chance) {
            new Entity({
              x, y,
              emoji: entityDef.emoji,
              type: entityDef.type,
              solid: entityDef.solid,
              dialogue: entityDef.dialogue,
              destination: entityDef.destination
            })
            break
          }
        }
      }
    }
  }

  function switchRealm(realmKey) {
    const newRealm = REALMS[realmKey]
    if (!newRealm || newRealm === currentRealm) return
    
    // Show transition
    transition.classList.add('active')
    
    setTimeout(() => {
      // Stop current music
      if (backgroundMusic) {
        backgroundMusic.pause()
        backgroundMusic.currentTime = 0
      }
      
      // Update realm
      currentRealm = newRealm
      realmInfo.textContent = newRealm.name
      
      // Clear and regenerate world
      clearEntities()
      applyRealmTerrain(newRealm)
      generateEntities(newRealm)
      
      // Update music
      backgroundMusic = new Audio(newRealm.music)
      backgroundMusic.loop = true
      backgroundMusic.volume = 0.3
      
      if (isPlaying) {
        backgroundMusic.play().catch(e => console.log('Audio play failed:', e))
      }
      
      // Move player to a safe spot (find empty tile)
      let newX = 2, newY = 2
      for (let attempts = 0; attempts < 50; attempts++) {
        const testX = Math.floor(Math.random() * COLS)
        const testY = Math.floor(Math.random() * ROWS)
        if (!entityGrid[testY][testX]) {
          newX = testX
          newY = testY
          break
        }
      }
      player.moveTo(newX, newY)
      updateCamera()
      
      // Hide transition
      setTimeout(() => {
        transition.classList.remove('active')
      }, 250)
    }, 250)
  }

  let cameraX = 2
  let cameraY = 2

  function clamp(val, min, max) {
    return Math.max(min, Math.min(max, val))
  }

  function updateInventory() {
    const haveWord = conlang.getEntry('have').form
    inventoryEl.textContent = `${haveWord}: ${player.inventory.join(' ')}`
  }

  function showDialogue(text, entity = null) {
    if (!entity) return

    let bubble = entity.el.querySelector('.speech-bubble')
    if (!bubble) {
      bubble = document.createElement('div')
      bubble.className = 'speech-bubble'
      bubble.style.position = 'absolute'
      bubble.style.left = '50%'
      bubble.style.top = '-0.2em'
      bubble.style.background = 'white'
      bubble.style.border = '1px solid black'
      bubble.style.padding = '4px 8px'
      bubble.style.borderRadius = '8px'
      bubble.style.fontSize = '1rem'
      bubble.style.zIndex = '30'
      bubble.style.whiteSpace = 'nowrap'
      bubble.style.transform = 'translate(-50%, -120%)'
      entity.el.appendChild(bubble)
    }
    bubble.textContent = text
    bubble.style.display = 'block'
    setTimeout(() => {
      if (bubble) bubble.style.display = 'none'
    }, 2000)
  }

  function updateCamera() {
    const marginX = Math.floor(VIEW_WIDTH / 2)
    const marginY = Math.floor(VIEW_HEIGHT / 2)
    
    if (player.x < cameraX - marginX + 1) cameraX = clamp(player.x + marginX - 1, marginX, COLS - marginX - 1)
    if (player.x > cameraX + marginX - 1) cameraX = clamp(player.x - marginX + 1, marginX, COLS - marginX - 1)
    if (player.y < cameraY - marginY + 1) cameraY = clamp(player.y + marginY - 1, marginY, ROWS - marginY - 1)
    if (player.y > cameraY + marginY - 1) cameraY = clamp(player.y - marginY + 1, marginY, ROWS - marginY - 1)

    const offsetX = clamp(cameraX - marginX, 0, COLS - VIEW_WIDTH) * tileWidth
    const offsetY = clamp(cameraY - marginY, 0, ROWS - VIEW_HEIGHT) * tileHeight
    worldEl.style.transform = `translate(${-offsetX}px, ${-offsetY}px)`
  }

  function toggleAudio() {
    if (isPlaying) {
      if (backgroundMusic) backgroundMusic.pause()
      audioToggle.textContent = 'üîá'
      isPlaying = false
    } else {
      if (backgroundMusic) {
        backgroundMusic.play().catch(e => console.log('Audio play failed:', e))
      }
      audioToggle.textContent = 'üîä'
      isPlaying = true
    }
  }

  window.addEventListener('keydown', e => {
    if (e.key === 'ArrowLeft') player.move(-1, 0)
    else if (e.key === 'ArrowRight') player.move(1, 0)
    else if (e.key === 'ArrowUp') player.move(0, -1)
    else if (e.key === 'ArrowDown') player.move(0, 1)
  })

  commandInput.addEventListener('keydown', e => {
    if (e.key === 'Enter') {
      const input = commandInput.value.trim()
      if (input) {
        processCommand(input)
        commandInput.value = ''
      }
    }
  })

  function resizeTiles() {
    const gamePane = document.querySelector('.game-pane')
    const gamePaneWidth = gamePane.clientWidth
    const gamePaneHeight = gamePane.clientHeight
    
    tileWidth = gamePaneWidth / VIEW_WIDTH
    tileHeight = gamePaneHeight / VIEW_HEIGHT
    worldEl.style.gridTemplateColumns = `repeat(${COLS}, ${tileWidth}px)`
    worldEl.style.gridTemplateRows = `repeat(${ROWS}, ${tileHeight}px)`
    worldEl.style.width = `${COLS * tileWidth}px`
    worldEl.style.height = `${ROWS * tileHeight}px`
    updateCamera()
  }

  // Command system
  function addCommandOutput(text, className = '') {
    const div = document.createElement('div')
    div.textContent = text
    if (className) div.className = className
    commandOutput.appendChild(div)
    commandOutput.scrollTop = commandOutput.scrollHeight
    
    // Keep only last 15 messages
    while (commandOutput.children.length > 15) {
      commandOutput.removeChild(commandOutput.firstChild)
    }
  }
  
  function processCommand(input) {
    const trimmedInput = input.toLowerCase().trim()
    
    addCommandOutput(`> ${input}`, '')
    
    // Check if input is a known word
    const entry = conlang.getEntry(trimmedInput)
    
    if (!entry) {
      addCommandOutput(getUIText('unknownCommand'), 'error')
      return
    }
    
    // Check if player knows this word
    if (!knownWords.has(entry.concept)) {
      addCommandOutput(getUIText('unknownCommand'), 'error')
      return
    }
    
    // Process based on word meaning
    switch (entry.concept) {
      case 'what':
        if (focusedEntity) {
          // Teach the player the word for the focused entity
          const entityWord = focusedEntity.conlangName
          const thisWord = conlang.getEntry('this').form
          
          addCommandOutput(`${thisWord} ${entityWord}`, 'success')
          
          // Add entity concept to known words
          knownWords.add(focusedEntity.concept)
          addCommandOutput(`${getUIText('learned')} ${focusedEntity.concept} = ${entityWord}`, 'info')
        } else {
          addCommandOutput(getUIText('notNear'), 'error')
        }
        break
        
      case 'say':
        addCommandOutput(`${getUIText('youSay')} ${entry.form}`, 'success')
        break
        
      case 'have':
        const haveLabel = getUIText('inventoryLabel')
        addCommandOutput(`${haveLabel} ${player.inventory.join(' ')}`, 'info')
        break
        
      case 'see':
        if (focusedEntity) {
          const isKnown = knownWords.has(focusedEntity.concept)
          const entityName = isKnown ? focusedEntity.conlangName : '???'
          addCommandOutput(`${getUIText('youSee')} ${entityName}`, 'info')
        } else {
          addCommandOutput(getUIText('notNear'), 'error')
        }
        break
        
      case 'know':
        addCommandOutput(`${getUIText('learned')}`, 'info')
        for (const word of knownWords) {
          const wordEntry = conlang.getEntry(word)
          if (wordEntry) {
            addCommandOutput(`  ${word} = ${wordEntry.form}`, 'success')
          }
        }
        break
        
      default:
        addCommandOutput(`${getUIText('youSay')} ${entry.form}`, 'success')
    }
  }
  
  function findNearbyEntity(entityType) {
    const directions = [
      { dx: 0, dy: 0 },   // same tile
      { dx: -1, dy: 0 },  // left
      { dx: 1, dy: 0 },   // right
      { dx: 0, dy: -1 },  // up
      { dx: 0, dy: 1 }    // down
    ]
    
    for (const dir of directions) {
      const checkX = player.x + dir.dx
      const checkY = player.y + dir.dy
      
      if (checkX >= 0 && checkX < COLS && checkY >= 0 && checkY < ROWS) {
        const entity = entityGrid[checkY][checkX]
        if (entity && entity !== player && entity.concept === entityType) {
          return entity
        }
      }
    }
    return null
  }
  
  function findNearbyEntities(types) {
    const directions = [
      { dx: -1, dy: 0 }, { dx: 1, dy: 0 }, { dx: 0, dy: -1 }, { dx: 0, dy: 1 }
    ]
    
    const found = []
    for (const dir of directions) {
      const checkX = player.x + dir.dx
      const checkY = player.y + dir.dy
      
      if (checkX >= 0 && checkX < COLS && checkY >= 0 && checkY < ROWS) {
        const entity = entityGrid[checkY][checkX]
        if (entity && entity !== player && types.includes(entity.type)) {
          found.push(entity)
        }
      }
    }
    return found
  }

  audioToggle.addEventListener('click', toggleAudio)

  // Initialize the game
  let player = null
  
  function initializeGame() {
    createTileGrid()
    player = new Player({ x: 2, y: 2, emoji: 'üßù‚Äç‚ôÇÔ∏è' })
    switchRealm('forest') // Start in forest realm
    
    // Translate UI elements
    const consoleHeader = document.getElementById('consoleHeader')
    consoleHeader.textContent = getUIText('consoleHeader')
    
    const commandInput = document.getElementById('commandInput')
    commandInput.placeholder = getUIText('helpHint')
    
    // Welcome message in conlang
    addCommandOutput(getUIText('welcomeMessage'), 'success')
    addCommandOutput(getUIText('helpHint'), 'info')
    
    updateInventory()
  }

  window.addEventListener('resize', resizeTiles)
  
  initializeGame()
  resizeTiles()

  Object.assign(
    window, {
      conlang,
      player,
      knownWords,
      getUIText,
      addCommandOutput,
      updateInventory,
      findNearbyEntity,
      findNearbyEntities,
      switchRealm,
      showDialogue
    }
  )
</script>
</body>
</html>