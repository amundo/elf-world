<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>elf world</title>
  <link rel="icon"
    href="data:image/svg+xml,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20width%3D'48'%20height%3D'48'%20viewBox%3D'0%200%2016%2016'%3E%3Ctext%20x%3D'0'%20y%3D'14'%3E%F0%9F%A7%9D%E2%80%8D%E2%99%82%EF%B8%8F%3C%2Ftext%3E%3C%2Fsvg%3E" />
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: sans-serif;
    }

    .view {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      display: flex;
    }

    .game-pane {
      flex: 1;
      position: relative;
      overflow: hidden;
    }

    .console-pane {
      width: 400px;
      background: rgba(0, 0, 0, 0.95);
      color: #00ff00;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      border-left: 2px solid #333;
    }

    .world {
      position: absolute;
      display: grid;
      transition: transform 0.3s ease-out;
      width: 100%;
      height: 100%;
    }

    .tile {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      position: relative;
      border: 1px solid rgba(0, 0, 0, 0.05);
    }

    .entity {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }

    .player {
      z-index: 15;
    }

    .portal {
      z-index: 12;
      animation: portal-glow 2s ease-in-out infinite alternate;
    }

    @keyframes portal-glow {
      from {
        filter: brightness(1) drop-shadow(0 0 5px currentColor);
      }

      to {
        filter: brightness(1.3) drop-shadow(0 0 15px currentColor);
      }
    }

    .ui {
      position: absolute;
      top: 0;
      left: 0;
      padding: 0.5rem;
      font-size: 1.2rem;
      background: rgba(255, 255, 255, 0.8);
      z-index: 20;
    }

    .realm-info {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      padding: 0.5rem 1rem;
      font-size: 1.2rem;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      z-index: 20;
      border-radius: 0 0 8px 8px;
    }

    .audio-controls {
      position: absolute;
      top: 0;
      right: 0;
      padding: 0.5rem;
      background: rgba(255, 255, 255, 0.8);
      z-index: 20;
      font-size: 1.2rem;
      cursor: pointer;
      user-select: none;
    }

    .audio-controls:hover {
      background: rgba(255, 255, 255, 0.9);
    }

    .dialogue {
      position: absolute;
      bottom: 10px;
      left: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 1rem;
      font-size: 1.2rem;
      display: none;
      z-index: 20;
      border-radius: 8px;
    }

    .console-header {
      background: rgba(0, 0, 0, 0.8);
      color: #00ff00;
      padding: 0.5rem;
      border-bottom: 1px solid #333;
      font-weight: bold;
      text-align: center;
    }

    .command-output {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
      font-size: 0.9rem;
      min-height: 0;
    }

    .command-output div {
      margin: 2px 0;
      line-height: 1.4;
    }

    .command-input-area {
      padding: 0.5rem;
      border-top: 1px solid #333;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .command-prompt {
      color: #00ff00;
      font-weight: bold;
    }

    .command-input {
      flex: 1;
      background: transparent;
      border: none;
      color: #00ff00;
      font-family: 'Courier New', monospace;
      font-size: 1rem;
      outline: none;
    }

    .error {
      color: #ff6666;
    }

    .success {
      color: #66ff66;
    }

    .info {
      color: #6666ff;
    }

    .realm-transition {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: black;
      z-index: 100;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease-in-out;
    }

    .realm-transition.active {
      opacity: 1;
    }
  </style>
</head>

<body>

  <div class="view">
    <div class="game-pane">
      <div id="world" class="world"></div>
      <div class="ui" id="inventory">Inventory: üçé</div>
      <div class="realm-info" id="realmInfo">Forest Realm</div>
      <div class="audio-controls" id="audioToggle">üîá</div>
      <div class="dialogue" id="dialogueBox">Hello!</div>
      <div class="realm-transition" id="transition"></div>
    </div>

    <div class="console-pane">
      <div class="console-header" id="consoleHeader">WORD LEARN</div>
      <div class="command-output" id="commandOutput"></div>
      <div class="command-input-area">
        <span class="command-prompt">></span>
        <input type="text" class="command-input" id="commandInput" placeholder="">
      </div>
    </div>
  </div>

  <script type="module">
    // Simple ConlangEngine embedded directly
    class ConlangEngine {
      constructor(config = {}) {
        this.consonants = config.consonants || ['p', 't', 'k', 's', 'n', 'm', 'l', 'r', 'w', 'j']
        this.vowels = config.vowels || ['a', 'e', 'i', 'o', 'u']
        this.syllableStructures = config.syllableStructures || ['CV', 'CVC', 'V', 'VC']
        this.seed = config.seed || null
        this.rng = this.createRNG(this.seed)
        this.lexicon = new Map()
        this.seedWords = [
          "GO", "HAVE", "HEAR", "HELLO", "HERE", "HOW", "KNOW", "LEARN", 
          "NEAR", "NOT", "OPEN", "SAY", "SEE", "TAKE", "THING", "THIS", 
          "USE", "WHAT", "WHERE", "WHO", "WORD", "WORLD"
        ]
        this.initializeLexicon()
      }

      createRNG(seed) {
        if (!seed) return Math.random
        let s = seed
        return function () {
          s = Math.sin(s) * 10000
          return s - Math.floor(s)
        }
      }

      initializeLexicon() {
        for (const word of this.seedWords) {
          const form = this.generateRandomWord()
          this.lexicon.set(word.toLowerCase(), form)
        }
      }

      generateSyllable(structure) {
        let syllable = ''
        for (const segment of structure) {
          if (segment === 'C') {
            syllable += this.consonants[Math.floor(this.rng() * this.consonants.length)]
          } else if (segment === 'V') {
            syllable += this.vowels[Math.floor(this.rng() * this.vowels.length)]
          }
        }
        return syllable
      }

      generateRandomWord() {
        const numSyllables = Math.floor(this.rng() * 3) + 1
        let word = ''
        for (let i = 0; i < numSyllables; i++) {
          const structure = this.syllableStructures[Math.floor(this.rng() * this.syllableStructures.length)]
          word += this.generateSyllable(structure)
        }
        return word
      }

      getWord(concept) {
        const key = concept.toLowerCase()
        if (this.lexicon.has(key)) {
          return this.lexicon.get(key)
        }
        const form = this.generateRandomWord()
        this.lexicon.set(key, form)
        return form
      }

      hasWord(concept) {
        return this.lexicon.has(concept.toLowerCase())
      }
    }

    const COLS = 30
    const ROWS = 20
    const VIEW_WIDTH = 10
    const VIEW_HEIGHT = 8

    let tileWidth, tileHeight
    const worldEl = document.getElementById('world')
    const dialogueBox = document.getElementById('dialogueBox')
    const inventoryEl = document.getElementById('inventory')
    const audioToggle = document.getElementById('audioToggle')
    const realmInfo = document.getElementById('realmInfo')
    const transition = document.getElementById('transition')
    const commandInput = document.getElementById('commandInput')
    const commandOutput = document.getElementById('commandOutput')

    // Current realm and audio
    let currentRealm = null
    let backgroundMusic = null
    let isPlaying = false

    // Initialize conlang
    const conlang = new ConlangEngine({ seed: Math.floor(Math.random() * 1000) })

    // Player's learned vocabulary - start with basic seed words
    const knownWords = new Set(['what', 'this'])

    // Game state
    let selectedEntity = null
    let focusedEntity = null

    // UI translation system - simplified and cleaned up
    function translateGloss(glossText) {
      if (!(glossText.startsWith('[') && glossText.endsWith(']'))) {
        return glossText
      }
      const innerGlossText = glossText.slice(1, -1).toLowerCase()
      const tokenizer = new Intl.Segmenter('en', { granularity: 'word' })
      const tokens = Array.from(tokenizer.segment(innerGlossText))
        .filter(segment => segment.isWordLike)
        .map(segment => segment.segment)
      return tokens.map(word => {
        const conlangWord = conlang.getWord(word)
        return conlangWord || word
      }).join(' ')
    }

    function getUIText(key) {
      const uiGlosses = {
        consoleHeader: '[word learn]',
        inventoryLabel: '[have]',
        welcomeMessage: '[hello world]!',
        helpHint: '[say what near thing]',
        unknownCommand: '[not know word]',
        notNear: '[not near]',
        learned: '[now know]',
        youSay: '[you say]',
        youSee: '[you see]',
        focus: '[this]'
      }

      const gloss = uiGlosses[key] || `[${key}]`
      return translateGloss(gloss)
    }

    // Grid of tile DOM elements
    const tileElements = Array.from({ length: ROWS }, () => Array(COLS).fill(null))
    // Grid of entity data
    const entityGrid = Array.from({ length: ROWS }, () => Array(COLS).fill(null))

  // Realm definitions
  const REALMS = {
    forest: {
      name: "Forest Realm",
      music: "audio/woodland-fantasy.mp3",
      terrain: {
        primary: { color: "#90EE90", weight: 0.7 },   // Light green
        secondary: { color: "#228B22", weight: 0.2 }, // Forest green  
        accent: { color: "#4169E1", weight: 0.1 }     // Blue (water)
      },
      entities: [
        { type: 'object', emoji: 'üå≤', chance: 0.12, solid: true },
        { type: 'object', emoji: 'ü™®', chance: 0.06, solid: true },
        { type: 'enemy', emoji: 'üêç', chance: 0.03, dialogue: 'A wild snake appears!' },
        { type: 'enemy', emoji: 'ü¶á', chance: 0.02, dialogue: 'A bat swoops down!' },
        { type: 'npc', emoji: 'üë¥', chance: 0.02, dialogue: 'Welcome to the forest, traveler!' },
        { type: 'npc', emoji: 'üßô‚Äç‚ôÇÔ∏è', chance: 0.01, dialogue: 'The forest magic is strong here!' },
        { type: 'portal', emoji: 'üåÄ', chance: 0.003, destination: 'wraith' },
        { type: 'portal', emoji: '‚ú®', chance: 0.003, destination: 'fairy' }
      ]
    },
    wraith: {
      name: "Wraith Realm", 
      music: "audio/the-wraiths-of-winter.mp3",
      terrain: {
        primary: { color: "#2F2F2F", weight: 0.6 },   // Dark gray
        secondary: { color: "#1C1C1C", weight: 0.3 }, // Very dark gray
        accent: { color: "#4B0082", weight: 0.1 }     // Dark purple
      },
      entities: [
        { type: 'object', emoji: 'ü™¶', chance: 0.08, solid: true },
        { type: 'object', emoji: 'üåô', chance: 0.03, solid: false },
        { type: 'enemy', emoji: 'üíÄ', chance: 0.04, dialogue: 'A skull rattles menacingly!' },
        { type: 'enemy', emoji: 'üßü', chance: 0.03, dialogue: 'A zombie groans and approaches!' },
        { type: 'enemy', emoji: 'üëª', chance: 0.02, dialogue: 'A wraith materializes before you!' },
        { type: 'npc', emoji: 'üßô‚Äç‚ôÄÔ∏è', chance: 0.01, dialogue: 'The dead whisper secrets here...' },
        { type: 'npc', emoji: 'üîÆ', chance: 0.005, dialogue: 'The crystal shows visions of other realms...' },
        { type: 'npc', emoji: 'üîÆ', chance: 0.005, dialogue: 'The crystal shows visions of other realms...' },
        { type: 'portal', emoji: 'üåÄ', chance: 0.003, destination: 'forest' },
        { type: 'portal', emoji: '‚ú®', chance: 0.003, destination: 'fairy' }
      ]
    },
    fairy: {
      name: "Fairy Realm",
      music: "audio/epic-orchestral-fantasy.mp3", 
      terrain: {
        primary: { color: "#FFB6C1", weight: 0.4 },   // Light pink
        secondary: { color: "#E6E6FA", weight: 0.3 }, // Lavender
        accent: { color: "#98FB98", weight: 0.3 }     // Pale green
      },
      entities: [
        { type: 'object', emoji: 'üå∏', chance: 0.15, solid: false },
        { type: 'object', emoji: 'üå∫', chance: 0.08, solid: false },
        { type: 'object', emoji: 'üçÑ', chance: 0.1, solid: true },
        { type: 'object', emoji: 'ü¶ã', chance: 0.06, solid: false },
        { type: 'enemy', emoji: 'üêù', chance: 0.02, dialogue: 'A magical bee buzzes around you!' },
        { type: 'enemy', emoji: 'ü¶Ñ', chance: 0.01, dialogue: 'A unicorn prances nearby, but seems wary!' },
        { type: 'npc', emoji: 'üßö‚Äç‚ôÄÔ∏è', chance: 0.04, dialogue: 'Welcome to our enchanted realm!' },
        { type: 'npc', emoji: 'üßö‚Äç‚ôÇÔ∏è', chance: 0.03, dialogue: 'The fairy magic flows strong here!' },
        { type: 'npc', emoji: 'üëë', chance: 0.005, dialogue: 'I am the Fairy Queen. You are welcome in my domain.' },
        { type: 'portal', emoji: 'üåÄ', chance: 0.003, destination: 'forest' },
        { type: 'portal', emoji: 'üå´Ô∏è', chance: 0.003, destination: 'wraith' }
      ]
    }
  }


    class Entity {
      constructor({ x, y, emoji, type = 'entity', solid = false, dialogue = null, destination = null, concept = null }) {
        this.x = x
        this.y = y
        this.type = type
        this.solid = solid
        this.dialogue = dialogue
        this.destination = destination

        if (Array.isArray(emoji)) {
          this.emoji = emoji[Math.floor(Math.random() * emoji.length)]
        } else {
          this.emoji = emoji
        }

        this.concept = concept || this.getConceptFromEmoji(this.emoji)
        this.conlangName = conlang.getWord(this.concept)

        this.el = document.createElement('div')
        this.el.className = `entity ${type}`
        this.el.textContent = this.emoji
        this.el.title = `${this.concept} (${this.conlangName})`

        this.el.addEventListener('click', () => this.inspect())

        const tile = tileElements[y][x]
        if (tile) {
          tile.appendChild(this.el)
        }

        entityGrid[y][x] = this
      }

      speak() {
        return this.dialogue || 'The entity makes no sound.'
      }

      getConceptFromEmoji(emoji) {
        const emojiMap = {
          'üå≤': 'tree', 'ü™®': 'rock', 'üêç': 'snake', 'ü¶á': 'bat',
          'üë¥': 'elder', 'üßô‚Äç‚ôÇÔ∏è': 'wizard', 'üåÄ': 'portal', '‚ú®': 'portal',
          'üå´Ô∏è': 'portal', 'ü™¶': 'grave', 'üåô': 'moon', 'üíÄ': 'skull',
          'üßü': 'zombie', 'üëª': 'ghost', 'üßô‚Äç‚ôÄÔ∏è': 'witch', 'üîÆ': 'crystal',
          'üå∏': 'flower', 'üå∫': 'flower', 'üçÑ': 'mushroom', 'ü¶ã': 'butterfly',
          'üêù': 'bee', 'ü¶Ñ': 'unicorn', 'üßö‚Äç‚ôÄÔ∏è': 'fairy', 'üßö‚Äç‚ôÇÔ∏è': 'fairy',
          'üëë': 'queen'
        }
        return emojiMap[emoji] || 'entity'
      }

      inspect() {
        const isKnown = knownWords.has(this.concept)
        
        addCommandOutput(`${getUIText('youSee')} ${this.emoji}`)
        if (isKnown) {
          addCommandOutput(`${this.conlangName}`, 'success')
        } else {
          addCommandOutput(`???`, 'error')
        }

        selectedEntity = this
      }

      moveTo(newX, newY) {
        if (this.el.parentElement) {
          this.el.parentElement.removeChild(this.el)
        }
        entityGrid[this.y][this.x] = null

        this.x = newX
        this.y = newY
        const tile = tileElements[newY][newX]
        if (tile) {
          tile.appendChild(this.el)
        }
        entityGrid[newY][newX] = this
      }

      onInteract(player) {
        if (this.type === 'portal') {
          switchRealm(this.destination)
        } else if (this.dialogue) {
          const greeting = knownWords.has('hello') ? conlang.getWord('hello') : 'hello'
          const spokenText = this.speak()
          showDialogue(`${greeting}! ${spokenText}`, this)
        }
      }
    }

    class Player extends Entity {
      constructor({ x, y, emoji }) {
        super({ x, y, emoji, type: 'player' })
        this.inventory = ['üçé']
        this.concept = 'player'
        this.conlangName = conlang.getWord('player')
      }

      move(dx, dy) {
        const tx = clamp(this.x + dx, 0, COLS - 1)
        const ty = clamp(this.y + dy, 0, ROWS - 1)
        const entity = entityGrid[ty][tx]

        if (entity?.solid) return

        if (entity?.type === 'portal') {
          entity.onInteract(this)
          return
        }

        this.moveTo(tx, ty)
        updateCamera()
        this.checkAdjacentInteractions()
      }

      checkAdjacentInteractions() {
        const directions = [
          { dx: -1, dy: 0 }, { dx: 1, dy: 0 }, { dx: 0, dy: -1 }, { dx: 0, dy: 1 }
        ]

        let closestEntity = null
        let closestDistance = Infinity

        for (const dir of directions) {
          const checkX = this.x + dir.dx
          const checkY = this.y + dir.dy

          if (checkX >= 0 && checkX < COLS && checkY >= 0 && checkY < ROWS) {
            const entity = entityGrid[checkY][checkX]
            if (entity && entity !== player) {
              const distance = Math.abs(dir.dx) + Math.abs(dir.dy)
              if (distance < closestDistance) {
                closestDistance = distance
                closestEntity = entity
              }
            }
          }
        }

        if (focusedEntity !== closestEntity) {
          focusedEntity = closestEntity
          if (focusedEntity) {
            addCommandOutput(`${getUIText('focus')} ${focusedEntity.emoji}`)
          }
        }

        for (const dir of directions) {
          const checkX = this.x + dir.dx
          const checkY = this.y + dir.dy

          if (checkX >= 0 && checkX < COLS && checkY >= 0 && checkY < ROWS) {
            const entity = entityGrid[checkY][checkX]
            if (entity && (entity.type === 'npc' || entity.type === 'enemy')) {
              entity.onInteract(this)
              break
            }
          }
        }
      }
    }

    function createTileGrid() {
      worldEl.innerHTML = ''
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          const tile = document.createElement('div')
          tile.className = 'tile'
          tile.dataset.x = x
          tile.dataset.y = y
          worldEl.appendChild(tile)
          tileElements[y][x] = tile
        }
      }
    }

    function applyRealmTerrain(realm) {
      const terrain = realm.terrain
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          const tile = tileElements[y][x]
          const rand = Math.random()

          if (rand < terrain.accent.weight) {
            tile.style.backgroundColor = terrain.accent.color
          } else if (rand < terrain.accent.weight + terrain.secondary.weight) {
            tile.style.backgroundColor = terrain.secondary.color
          } else {
            tile.style.backgroundColor = terrain.primary.color
          }
        }
      }
    }

    function clearEntities() {
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          entityGrid[y][x] = null
          const tile = tileElements[y][x]
          if (tile) {
            const entities = tile.querySelectorAll('.entity:not(.player)')
            entities.forEach(entity => entity.remove())
          }
        }
      }
    }

    function generateEntities(realm) {
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          if (player && x === player.x && y === player.y) continue

          for (const entityDef of realm.entities) {
            if (Math.random() < entityDef.chance) {
              new Entity({
                x, y,
                emoji: entityDef.emoji,
                type: entityDef.type,
                solid: entityDef.solid,
                dialogue: entityDef.dialogue,
                destination: entityDef.destination,
                concept: entityDef.concept
              })
              break
            }
          }
        }
      }
    }

    function switchRealm(realmKey) {
      console.log(`Switching to realm: ${realmKey}`)

      const newRealm = REALMS[realmKey]

      if (!newRealm || newRealm === currentRealm) return

      transition.classList.add('active')

      setTimeout(() => {
        if (backgroundMusic) {
          backgroundMusic.pause()
          backgroundMusic.currentTime = 0
        }

        currentRealm = newRealm
        realmInfo.textContent = newRealm.name

        clearEntities()
        applyRealmTerrain(newRealm)
        generateEntities(newRealm)

        backgroundMusic = new Audio(newRealm.music)

        let newX = 2, newY = 2
        for (let attempts = 0; attempts < 50; attempts++) {
          const testX = Math.floor(Math.random() * COLS)
          const testY = Math.floor(Math.random() * ROWS)
          if (!entityGrid[testY][testX]) {
            newX = testX
            newY = testY
            break
          }
        }
        player.moveTo(newX, newY)
        updateCamera()

        setTimeout(() => {
          transition.classList.remove('active')
        }, 250)
      }, 250)
    }

    let cameraX = 2
    let cameraY = 2

    function clamp(val, min, max) {
      return Math.max(min, Math.min(max, val))
    }

    function updateInventory() {
      const haveWord = conlang.getWord('have')
      inventoryEl.textContent = `${haveWord}: ${player.inventory.join(' ')}`
    }

    function showDialogue(text, entity = null) {
      if (!entity) return

      let bubble = entity.el.querySelector('.speech-bubble')
      if (!bubble) {
        bubble = document.createElement('div')
        bubble.className = 'speech-bubble'
        bubble.style.position = 'absolute'
        bubble.style.left = '50%'
        bubble.style.top = '-0.2em'
        bubble.style.background = 'white'
        bubble.style.border = '1px solid black'
        bubble.style.padding = '4px 8px'
        bubble.style.borderRadius = '8px'
        bubble.style.fontSize = '1rem'
        bubble.style.zIndex = '30'
        bubble.style.whiteSpace = 'nowrap'
        bubble.style.transform = 'translate(-50%, -120%)'
        entity.el.appendChild(bubble)
      }
      bubble.textContent = text
      bubble.style.display = 'block'
      setTimeout(() => {
        if (bubble) bubble.style.display = 'none'
      }, 2000)
    }

    function updateCamera() {
      const marginX = Math.floor(VIEW_WIDTH / 2)
      const marginY = Math.floor(VIEW_HEIGHT / 2)

      if (player.x < cameraX - marginX + 1) cameraX = clamp(player.x + marginX - 1, marginX, COLS - marginX - 1)
      if (player.x > cameraX + marginX - 1) cameraX = clamp(player.x - marginX + 1, marginX, COLS - marginX - 1)
      if (player.y < cameraY - marginY + 1) cameraY = clamp(player.y + marginY - 1, marginY, ROWS - marginY - 1)
      if (player.y > cameraY + marginY - 1) cameraY = clamp(player.y - marginY + 1, marginY, ROWS - marginY - 1)

      const offsetX = clamp(cameraX - marginX, 0, COLS - VIEW_WIDTH) * tileWidth
      const offsetY = clamp(cameraY - marginY, 0, ROWS - VIEW_HEIGHT) * tileHeight
      worldEl.style.transform = `translate(${-offsetX}px, ${-offsetY}px)`
    }

    function toggleAudio() {
      if (isPlaying) {
        if (backgroundMusic) backgroundMusic.pause()
        audioToggle.textContent = 'üîá'
        isPlaying = false
      } else {
        if (backgroundMusic) {
          backgroundMusic.play().catch(e => console.log('Audio play failed:', e))
        }
        audioToggle.textContent = 'üîä'
        isPlaying = true
      }
    }

    window.addEventListener('keydown', e => {
      if (e.key === 'ArrowLeft') player.move(-1, 0)
      else if (e.key === 'ArrowRight') player.move(1, 0)
      else if (e.key === 'ArrowUp') player.move(0, -1)
      else if (e.key === 'ArrowDown') player.move(0, 1)
    })

    commandInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        const input = commandInput.value.trim()
        if (input) {
          processCommand(input)
          commandInput.value = ''
        }
      }
    })

    function resizeTiles() {
      const gamePane = document.querySelector('.game-pane')
      const gamePaneWidth = gamePane.clientWidth
      const gamePaneHeight = gamePane.clientHeight

      tileWidth = gamePaneWidth / VIEW_WIDTH
      tileHeight = gamePaneHeight / VIEW_HEIGHT
      worldEl.style.gridTemplateColumns = `repeat(${COLS}, ${tileWidth}px)`
      worldEl.style.gridTemplateRows = `repeat(${ROWS}, ${tileHeight}px)`
      worldEl.style.width = `${COLS * tileWidth}px`
      worldEl.style.height = `${ROWS * tileHeight}px`
      updateCamera()
    }

    // Command system - FIXED
    function addCommandOutput(text, className = '') {
      const div = document.createElement('div')
      div.textContent = text
      if (className) div.className = className
      commandOutput.appendChild(div)
      commandOutput.scrollTop = commandOutput.scrollHeight

      // Keep only last 15 messages
      while (commandOutput.children.length > 15) {
        commandOutput.removeChild(commandOutput.firstChild)
      }
    }

    function processCommand(input) {
      const trimmedInput = input.toLowerCase().trim()

      // Show what the player typed
      addCommandOutput(`> ${input}`)

      // Check if input is a known word in the conlang
      if (!conlang.hasWord(trimmedInput)) {
        addCommandOutput(getUIText('unknownCommand'), 'error')
        return
      }

      // Get the conlang word
      const conlangWord = conlang.getWord(trimmedInput)

      // Check if player knows this word
      if (!knownWords.has(trimmedInput)) {
        addCommandOutput(getUIText('unknownCommand'), 'error')
        return
      }

      // Process based on word meaning
      switch (trimmedInput) {
        case 'what':
          if (focusedEntity) {
            // Teach the player the word for the focused entity
            const entityWord = focusedEntity.conlangName
            const thisWord = conlang.getWord('this')

            addCommandOutput(`${thisWord} ${entityWord}`, 'success')

            // Add entity concept to known words
            knownWords.add(focusedEntity.concept)
            const learnedText = getUIText('learned')
            addCommandOutput(`${learnedText}: ${focusedEntity.concept} = ${entityWord}`, 'info')
          } else {
            addCommandOutput(getUIText('notNear'), 'error')
          }
          break

        case 'say':
          const youSayText = getUIText('youSay')
          addCommandOutput(`${youSayText} ${conlangWord}`, 'success')
          break

        case 'have':
          const haveText = conlang.getWord('have')
          addCommandOutput(`${haveText}: ${player.inventory.join(' ')}`, 'info')
          break

        case 'see':
          if (focusedEntity) {
            const isKnown = knownWords.has(focusedEntity.concept)
            const entityName = isKnown ? focusedEntity.conlangName : '???'
            const youSeeText = getUIText('youSee')
            addCommandOutput(`${youSeeText} ${entityName}`, 'info')
          } else {
            addCommandOutput(getUIText('notNear'), 'error')
          }
          break

        case 'know':
          const learnedText = getUIText('learned')
          addCommandOutput(learnedText, 'info')
          for (const word of knownWords) {
            const wordForm = conlang.getWord(word)
            addCommandOutput(`  ${word} = ${wordForm}`, 'success')
          }
          break

        default:
          const youSayText2 = getUIText('youSay')
          addCommandOutput(`${youSayText2} ${conlangWord}`, 'success')
      }
    }

    audioToggle.addEventListener('click', toggleAudio)

    // Initialize the game
    let player = null

    function initializeGame() {
      createTileGrid()
      player = new Player({ x: 2, y: 2, emoji: 'üßù‚Äç‚ôÇÔ∏è' })
      switchRealm('fairy') // Start in fairy realm

      // Translate UI elements
      const consoleHeader = document.getElementById('consoleHeader')
      consoleHeader.textContent = getUIText('consoleHeader')

      commandInput.placeholder = getUIText('helpHint')

      // Welcome message in conlang
      addCommandOutput(getUIText('welcomeMessage'), 'success')
      addCommandOutput(getUIText('helpHint'), 'info')

      updateInventory()
    }

    window.addEventListener('resize', resizeTiles)

    initializeGame()
    resizeTiles()

    // Expose useful functions for debugging
    Object.assign(window, {
      player,
      conlang,
      knownWords,
      getUIText,
      translateGloss,
      addCommandOutput,
      showDialogue
    })


    Object.assign(window, {
      switchRealm,
      updateCamera,
      updateInventory,
      applyRealmTerrain,
      generateEntities,
      clearEntities,
      backgroundMusic,
    })
  </script>
</body>

</html>