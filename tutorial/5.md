---
title: "Tutorial 5: Who’s the boss?"
author: Patrick Hall
---

In the last tutorial, we created a `World` class that loads a game world from a
JSON file, processes the terrain and actors, and provides access to the player
and NPCs. We also rendered a simple text representation of the world in the
console.

In this tutorial, we’re going to broach the topic of interactivity. So far, our
game world is static: the player and NPCs are just sitting there. To make the
game more interesting, we need to allow the player to move around and interact
with the world.

But we’re going to do so with a forward-thinking approach. We want a system that
will be compaitble with an instance of the game running on a server (the single
source of truth for the game state), and a client (the user’s browser) that
renders the game state and sends user actions to the server.

We _could_ simply listen for keyboard events in the browser, and directly update
the player’s position:

```javascript
document.addEventListener("keydown", (event) => {
  switch (event.key) {
    case "ArrowUp":
      world.player.y -= 1
      break
    case "ArrowDown":
      world.player.y += 1
      break
    case "ArrowLeft":
      world.player.x -= 1
      break
    case "ArrowRight":
      world.player.x += 1
      break
  }
  console.clear()
  console.log(world.debugRender())
})
```

This would work, sort of. But we want a world where multiple players can
interact with each other and the world. If we had a server running the game, and
multiple clients connected to it, we’d have to figure out how to sync the game
state between the server and all the clients.

## The command object

So, instead of directly updating the player’s position, we’re going to create a
command object that represents the user’s intent. The command object will be
sent to the game, which will then determine whether the move is valid, and
return an updated game state.

The component responsible for listening for, sending, and (re-)rendering the
game will be a different web component called `<world-view>`. It will contain
all the `<game-cell>` components, and will be responsible for rendering the
world and listening for user input. The name `<world-view>` seems appropriate,
since it is a view onto the whole world data structure. The world view is
instantiating, well, everything. It is creating a “legible” representation of
the world, fetching it from the server, rendering it, and listening for user
input. One big change here is that it’s the `Game` on the server that is
actually loading the world data file, and the `WorldView` on the client is just
receiving that data and rendering it. We _want_ the `<world-view>` to as dumb as
possible: listen, submit, receive updates, render, repeat.

As a rough skeleton, we’ll need these methods:

```javascript
class WorldView extends HTMLElement {
  constructor() {
    super()
    this.world = new World()
    this.camera = new Camera(this.world)
  }
  
  connectedCallback() {
    this.connectWebSocket()
    this.handleKeydown = (event) => this.handleInput(event)

    document.addEventListener('keydown', this.handleKeydown)
  }

  update(worldData){
    this.world.data = worldData
    this.render()
  }

  connectWebSocket(){
    this.webSocket = new WebSocket('ws://localhost:8080')
    this.webSocket.onmessage = (event) => {
      const worldData = JSON.parse(event.data)
      this.update(worldData)
    }
  }

  createCommand(event) {
  }


  render(){
    // render world cells, actors, and items
  }

  handleKeydown(event) {
    switch event.key {
      case 'ArrowUp':
        return { type: 'move', direction: 'up' }
      case 'ArrowDown':
        return { type: 'move', direction: 'down' }
      case 'ArrowLeft':
        return { type: 'move', direction: 'left' }
      case 'ArrowRight':
        return { type: 'move', direction: 'right' }
      default:
        return null
    }

    let command = this.createCommand(event)
    if (command) {
      this.dispatchEvent(new CustomEvent('move', {
        detail: { command },
        bubbles: true
      }))
      this.sendCommand(command)
    }
  }
  
  handleInput(event) {
    const command = this.createCommand(event)
    this.dispatchEvent(new CustomEvent('game-command', { 
      detail: { command },
      bubbles: true 
    }))
    this.sendCommand(command)
  }
  
  async sendCommand(command){
    // Send the command 
    this.webSocket.send(JSON.stringify(command))
  }
}
```

## A `WebSocket`-enabled deno server

On the server side, we’ll need to set up a `WebSocket` server that listens for
incoming connections and messages. When a client sends a command, the server
will process it, update the game state, and broadcast the new state to all
connected clients.
