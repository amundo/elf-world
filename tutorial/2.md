---
title: "Tutorial 2: Displaying an Entity in a Game Cell"
author: Patrick Hall
---

Now that we have a basic game cell, let‚Äôs add an entity to it. An entity could
be anything: a player character, a monster, an item, etc.

```html
<game-cell></game-cell>
```

So let‚Äôs say we want to display a player character in the cell. We can represent
the entity as an object within the cell‚Äôs data structure:

```json
{
  "terrain": "grass",
  "entity": {
    "type": "player",
    "name": "Hero",
    "health": 100
  }
}
```

But this is a problematic approach for several reasons. First, it mixes
concerns: the cell is responsible for both terrain and entity data. Second, it
makes it harder to manage entities independently of cells. To address these
issues, we can separate the entity data from the cell data.

```json
{
  "terrain": "grass"
}
```

And we can represent the entity separately:

```json
{
  "type": "player",
  "emoji": "üßù‚Äç‚ôÇÔ∏è",
  "name": "Hero"
}
```

Then, we can pass the entity data to the cell as a separate property:

````html
This way, the cell is only concerned with its own data, and we can manage entities independently. 

Now, how do we display the entity in the cell? We can add an `entity` attribute to the `<game-cell>` element, and set it to the entity data.

We need to add a method to our `GameCell` class to handle rendering the entity. We can do this by checking if the `entity` attribute is set, and if so, rendering the entity within the cell.



```javascript
class GameCell extends HTMLElement {
  #data = {}
  #entity = null
  set data(data) {
    this.#data = data
    this.render()
  }
  get data() {
    return this.#data
  }
  set entity(entity) {
    this.#entity = entity
    this.render()
  }
  get entity() {
    return this.#entity
  }
  renderEntity(){
    if(this.#entity){
      let div = document.createElement('div')
      div.classList.add('entity')
      div.textContent = this.#entity.emoji
      this.append(div)
    }
  }
  render() {
    this.setAttribute('terrain', this.#data.terrain)
    this.renderEntity()
  }
}
customElements.define('game-cell', GameCell)
````

We‚Äôre setting the player via Javascript, not HTML, because the entity is dynamic
and will change frequently. Roughly, the pattern will look like this:

```javascript
const cell = document.createElement("game-cell")
cell.data = { terrain: "grass" }
cell.entity = { type: "player", emoji: "üßù‚Äç‚ôÇÔ∏è", name: "Hero" }
document.body.append(cell)
```

Note that the terrain is rendered into the `DOM` via an attribute, while the
entity is rendered as a child `div` within the cell. This allows us to style the
cell based on terrain, and the entity based on its own properties.

Here‚Äôs the whole code together:

Open in a new tab:

<a href="sample-02.html" target="_blank">sample-02.html</a>

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2.html: Game Cell with Entity Example</title>
    <style>
      game-cell {
        display: inline-block;
        width: 100px;
        height: 100px;
        border: 1px solid black;
        position: relative;
        font-size: 48px;
        text-align: center;
        line-height: 100px;
      }
      game-cell[terrain="grass"] {
        background-color: forestgreen;
      }
      game-cell[terrain="water"] {
        background-color: deepskyblue;
      }
      game-cell[terrain="mountains"] {
        background-color: gray;
      }
      .entity {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }
    </style>
  </head>
  <body>
    <script>
      class GameCell extends HTMLElement {
        #data = {}
        #entity = null
        set data(data) {
          this.#data = data
          this.render()
        }
        get data() {
          return this.#data
        }
        set entity(entity) {
          this.#entity = entity
          this.render()
        }
        get entity() {
          return this.#entity
        }
        renderEntity() {
          this.querySelectorAll(".entity").forEach((e) => e.remove())
          if (this.#entity) {
            let div = document.createElement("div")
            div.classList.add("entity")
            div.textContent = this.#entity.emoji
            this.append(div)
          }
        }
        render() {
          this.setAttribute("terrain", this.#data.terrain)
          this.renderEntity()
        }
      }
      customElements.define("game-cell", GameCell)
      const cell = document.createElement("game-cell")
      cell.data = { terrain: "grass" }
      cell.entity = { type: "player", emoji: "üßù‚Äç‚ôÇÔ∏è", name: "Hero" }
      document.body.append(cell)
    </script>
  </body>
</html>
```

In the next exciting episode, we‚Äôll explore the notion of separating data from
presentation in more depth, and come up with a basic game data structure.

<a href="3.html">Next: Tutorial 3 - A Game Data Structure</a>
