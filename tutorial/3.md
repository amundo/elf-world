---
title: "Tutorial 3: A Game Data Structure"
author: Patrick Hall
---

In the last tutorial, we had a `renderEntity` method which was called by the
`GameCell`'s `render` method. This method created a `div` with the entity's
emoji and added it to the cell.

Storing the `DOM` node that represents a player under a `DOM` node representing
a terrain cell makes sense, since the player is "in" that cell. But this is a
user interface decision. One could equally well store the `DOM` node as a
sibling of the terrain cells, and use something like `CSS` positioning or a
`CSS` grid to position the player. Ideally we would set things up so that we can
experiment with different `UI` approaches.

What would that take? Well, it would require separating the notion of our player
object from the way that object is rendered. It‚Äôs the old warhorse of separating
data from presentation. There is the world of the data matrix, which
encomapasses the whole world, and there is the world of the `UI` world, which is
bounded (by a camera, as we shall see later) to present only a section of the
whole world. The notion of the world may be represented as a grid of cells, but
those cells are not all rendered at once.

It‚Äôs worth noting that things may be happening in the world that are not being
rendered to the screen: characters are moving, events might be happening. Or, if
the game is networked, other players might be moving around in a different part
of the world, and only seeing _their_ viewport-full of rendered space.

We want our rendering layer to be as dumb as possible: when it‚Äôs handed data,
render it. When the player does something that might require the game to update
the world (like moving, or doing something), then it should send the request to
the game.

So, let‚Äôs reconsider our ‚Äúhero‚Äù:

```json
{
  "type": "player",
  "emoji": "üßù‚Äç‚ôÇÔ∏è",
  "name": "Bob"
}
```

None of those things is likely to change often, so let‚Äôs give it something
variable. How about a health value?

```json
{
  "type": "player",
  "emoji": "üßù‚Äç‚ôÇÔ∏è",
  "name": "Bob",
  "health": 100
}
```

This property could be displayed to the user in all kinds of ways. We could use
a simple `<meter>` tag:

<meter max=100 min=0 step=1 value=75></meter>

Or we could use a Zelda-style heart meter:

<span style=border-radius:4px;background-color:#eee;border-width:1px;border-color:#ccc;padding:4px;font-size:smaller;>‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏èü§ç</span>

There are pros and cons of each of these. These are `UI` decisions. Again,
ideally our system will allow us to experiment freely with such things.

## A game object

Here‚Äôs a first stab a data structure representing a more complete game. It now
encompasses our player, as well as a terrain structure (more on that in a bit),
and a

```json
{
  "actors": [
    {
      "emoji": "üßù‚Äç‚ôÇÔ∏è",
      "type": "player",
      "name": "Bob",
      "health": 100
    },
    {
      "emoji": "üë∫",
      "type": "goblin",
      "name": "Bogzor",
      "health": 10
    },
    {
      "emoji": "ü¶Ñ",
      "type": "unicorn",
      "name": "Thilly",
      "health": 25
    }
  ],
  "terrain": [
    ["grass", "grass", "grass", "grass", "grass"],
    ["grass", "water", "water", "water", "grass"],
    ["grass", "water", "water", "stone", "grass"],
    ["grass", "grass", "grass", "grass", "grass"],
    ["grass", "grass", "grass", "grass", "grass"]
  ]
}
```

This data structure shows a player object in the context of a larger game
object. It‚Äôs fun to play around with structures like this. There are a million
ways to structure such information. For instance, we might place the player in a
separate property from the other (non-player character or NPC) "actors":

```json
{
  "player": {
      "emoji": "üßù‚Äç‚ôÇÔ∏è",
      "type": "player",
      "name": "Bob",
      "health": 100
  },
  "actors": [
    { "emoji": "üë∫" ‚Ä¶ },
    { "emoji": "ü¶Ñ" ‚Ä¶ }
  ],
  "terrain": [
    ["grass", ‚Ä¶ ],
    ‚Ä¶
  ]
}
```

We could even have arrays for `enemy` actors (like goblins) and `friend` actors
(like unicorns). Or, we could have a "team" property, say, with values of `good`
or `evil`.

But each such decision has consequences for code: what happens if an evil
"enemy" actor somehow turns good? What if the user acquires minions that obey
commands ‚Äî are those "non-player" characters? It depends on the game.

So I try to minimize the number of properties at first is the best approach. the
first approach could handle adding a second player (via a `WebSocket`, say)
without changing the structure or complicating code too much.

We‚Äôll stick with this game structure for now. It should be enough for us to
render our world grid and some actors. In the next tutorial we‚Äôll create a
`World` class which creates a game instance a structure like this, independent
of the `UI`.

<a href="4.html">Next: Tutorial 4 - A World Class</a>
