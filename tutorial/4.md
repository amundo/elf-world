---
title: "Tutorial 4: A World class"
author: Patrick Hall
---

As we mentioned before, we’re going to strictly separate data and presentation. So even though we began our series of tutorials with a Web Component called `<game-cell>` that displayed a (very simple) `UI` element in our user interface, now we are going to be operating purely in the data world. Here’s a sample game data structure that we can use to create a new world.


```javascript
class World {
  #data = { "actors": [], "terrain": [] }
  constructor(){
    console.log('World created')
  }

  async load(url){
    console.log(`Loading world data from ${url}...`)
    url = new URL('./world1.json', import.meta.url) // @TODO: remove for production
    let response = await fetch(url)
    let data = await response.json()
    this.data = data
  }

  buildGrid(terrain){
    let grid = terrain.map(row => row.map(cell => ({
      type: cell
    })))
    this.#data.terrain = grid
  }

  processData(gameData){
    this.buildGrid(gameData.terrain)
    this.processActors(gameData.actors)
  }

  processActors(actors){
    this.#data.actors = actors
    this.setPlayer()
  }

  setPlayer(id=null){
    let player
    if(id){
      player = this.#data.actors.find(actor => actor.id === id)
    } else {
      player = this.#data.actors.find(actor => actor.type === 'player')
    }
    this.#data.npcs = this.#data.actors.filter(actor => actor !== player)
    console.log(`npcs: ${this.#data.npcs.length}`)
    this.#data.player = player
  }

  set data(gameData){
    this.processData(gameData)
  }

  set terrain(terrain){ this.#data.terrain = terrain }

  get actors(){ return this.#data.actors }
  get terrain(){ return this.#data.terrain }
  get player(){ return this.#data.player }
  get npcs(){ return this.#data.npcs }
  
  debugRender(){ // use emojis to render a simple text version of the world
    let terrain = this.#data.terrain.map(row => row.map(cell => {
      if(cell.type === 'grass') return '🟩'
      if(cell.type === 'water') return '🟦'
      if(cell.type === 'mountain') return '⬜'
      return '⬜'
    }))
    this.#data.actors.forEach(actor => {
      let {x, y, emoji} = actor
      terrain[y][x] = emoji
    })
    let terrainText = terrain.map(row => row.join('')).join('\n')
    return terrainText
  }
}

export {
  World
}
```

And the code to load and render it:

```javascript
import { World } from './world.js'
let world = new World()
await world.load('world1.json')
world.debugRender()
```

This should work both in the browser console and a runtime like Deno. You should see a simple text representation of the world, with the player and NPC represented by their respective emojis.

Here’s what it looks like if you render it in `deno`:

```
$ deno -R sample-03.js
👤🟩🟩🟩🟩🟩🟩🟩🟩🟩
🟩👺🟦🟦🟩🟩🟩🟩🟩🟩
🟩🟦🟦🟦🟩🟩🟩🟩🟩🟩
🟩🟩🟩🟩🟩🟩🟩🟩🦄🟩
🟩🟩🟩🟩⬜⬜🟩🟩🟩🟩
🟩🟩🟩🟩⬜⬜🟩🟩🟩🟩
🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
🟩🟩🟩🟩🟩🟩🟩🟦🟦🟦
🟩🟩🟩🟩🟩🟩🟩🟦🟦🟦
🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
```

And if we make a tiny `HTML` page to load and log the world, that would look like:


```html
<!doctype html>
<title>World logger</title>
<script type="module">
  import { World } from './world.js'
  let world = new World()
  await world.load('world1.json')
  let terrainText = world.debugRender()
  console.log(terrainText)
</script>
```

You can try that out here:

<a href="sample-04-load-world.html" target="_blank">sample-04-load-world.html</a>

Or you can just click the button below to see the output in the console:

<style>
  pre {
    line-height:1;  
  }
</style>

<pre id="world-display">(Render world here)</pre>
<button id="load-world">Load and render world</button>

<script type="module">
  import { World } from './world.js'
  let world = new World()
  window.world = world
  await world.load('world1.json')
  
  let button = document.querySelector('#load-world')
  let pre = document.querySelector('#world-display')
  button.addEventListener('click', async () => {
    let terrainText = world.debugRender()
    pre.textContent = terrainText
  })
</script>


Neat! Our world is loading and rendering. 

I mean, it’s pretty pitiful as graphics go, but it shows that we can load a world from a JSON file, parse it, and render it into a grid map of the world. 

Now, open up your console and type `world`. You’ll see that I’ve added a reference to the world object: you can ask for `world.terrain` to see the terrain data, and `world.player` to see the player. 

There’s something weird, though: the player is in the first cell of the first row. However, look what happens when we ask for the “contents” of that cell:

```javascript
world.terrain[0][0]
// { type: "grass" }
```

The player is not part of the terrain data. That’s because the terrain is just the background: the grass, water, and mountains. The actors (the player and NPCs) are separate. We could _ask_ for the player’s position, though:

```javascript
world.player
// { id: 1, type: "player", x: 0, y: 0, emoji: "🧝" }
```

So we can see that the player is at `x:0, y:0`, which is the first cell of the first row. The goblin is at `x:1, y:1`, which is the second cell of the second row. And the unicorn is at `x:8, y:3`, which is the ninth cell of the fourth row.

This is why we have added a utility method that returns everything at a given `x,y` coordinate. This is the `at(x,y)` method:

```javascript
  at(x,y){
    let terrainCell = this.#data.terrain[y]?.[x] || null
    let actorsHere = this.#data.actors.filter(actor => actor.x === x && actor.y === y)
    return {
      terrain: terrainCell,
      actors: actorsHere
    }
  }
```

And so we can ask what is at `0,0`:

```javascript
world.at(0,0)
// { terrain: { type: "grass" }, actors: [ { id: 1, type: "player", x: 0, y: 0, emoji: "🧝" } ] }
```


In the next section, we’ll look at how we’re going to structure movement in our game, and how the client will communicate with the server to make moves.

<a href="5.html">Next: Tutorial 5: Who’s the boss?</a>